<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The War Vault ‚Äî Omniverse Edition (3D Map)</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Great+Vibes&display=swap" rel="stylesheet">
  <!-- Three.js (exposed on window for inline script) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    window.THREE = THREE;
    window.OrbitControls = OrbitControls;
    window.GLTFLoader = GLTFLoader;
  </script>
  <style>
    :root{
      --gold:#e6c57f;--accent:#b88c5c;--ink:#eee;--panel:#14131a;--mist:rgba(0,0,0,.55);--rune:rgba(230,197,127,.28);
      --paper:#f4ecd7;--paperEdge:#c9b27a;
    }
    *{box-sizing:border-box}
    body{
      margin:0;height:100vh;display:flex;flex-direction:column;background:#000;color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",sans-serif;overflow:hidden
    }
    body::before{
      content:""; position:fixed; inset:-10%;
      background:
        radial-gradient(60% 60% at 20% 10%, rgba(230,197,127,.12), transparent 60%),
        radial-gradient(50% 50% at 80% 0%, rgba(142,114,79,.10), transparent 55%),
        radial-gradient(45% 45% at 50% 100%, rgba(184,140,92,.10), transparent 55%),
        linear-gradient(180deg, #0b0a10, #0b0a10 40%, #0a0a12 100%);
      filter: saturate(110%) blur(0.3px);
      z-index:-1;
    }
    header{
      display:flex;align-items:center;justify-content:space-between;padding:.6rem 1rem;
      border-bottom:1px solid var(--accent);background:rgba(10,10,14,.9);backdrop-filter:blur(6px);
      position:relative;z-index:20; box-shadow: 0 2px 20px rgba(230,197,127,.06);
    }
    .brand{display:flex;flex-direction:column}
    .brand .title{font-family:'Cinzel',serif;font-weight:900;letter-spacing:.06em;color:var(--gold);text-shadow:0 0 12px rgba(230,197,127,.35);font-size:1.4rem}
    .brand .byline{font-family:'Great Vibes',cursive;font-size:1.5rem;line-height:1;color:var(--gold)}
    .actions{display:flex;gap:.5rem;align-items:center}
    .btn{background:rgba(35,35,45,.85);border:1px solid var(--accent);color:var(--ink);padding:.35rem .6rem;border-radius:8px;cursor:pointer}
    .btn:hover{background:var(--accent);color:#000;box-shadow:0 0 14px rgba(230,197,127,.35)}
    .btn.toggled{background:var(--accent);color:#000}
    input,select{background:#1c1b24;border:1px solid var(--accent);color:var(--ink);padding:.35rem;border-radius:6px;width:100%}

    #stage{flex:1;display:grid;grid-template-columns:320px 1fr 360px;min-height:0}
    #left-panel{background:var(--panel);border-right:1px solid var(--accent);overflow:auto;display:flex;flex-direction:column;
      box-shadow: inset 0 0 0 1px rgba(184,140,92,.22), inset 0 0 24px rgba(230,197,127,.06);}
    #right-panel{background:var(--panel);border-left:1px solid var(--accent);overflow:auto;
      box-shadow: inset 0 0 0 1px rgba(184,140,92,.22), inset 0 0 24px rgba(230,197,127,.06);}
    #map-container{position:relative;overflow:hidden;background:#111}

    /* 3D canvas lives behind 2D helper canvases, tokens etc. */
    #map3d{position:absolute;inset:0;z-index:0;display:block}

    .section{padding:12px;border-bottom:1px solid rgba(255,255,255,.08)}
    .section h3{margin:.1rem 0 .6rem;font-family:'Cinzel',serif;color:var(--gold);font-size:1rem}
    .row{display:flex;gap:.5rem;align-items:center;margin:.4rem 0}
    .row.stacked{flex-direction:column;align-items:stretch}

    /* (kept) canvases for grid/template/fog UI overlays; img map is hidden */
    #map{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;opacity:0;pointer-events:none}
    canvas{position:absolute;left:0;top:0;pointer-events:none}
    #grid-layer{z-index:2}
    #template-layer{z-index:3}
    #fog-layer{z-index:5}

    .token{
      position:absolute;border-radius:50%;background:#f44;color:#000;font-weight:800;
      display:flex;align-items:center;justify-content:center;user-select:none;cursor:grab;
      z-index:6;border:2px solid #fff;transform-origin:center;overflow:hidden
    }
    .token span{pointer-events:none}
    .token.has-img{background-size:cover;background-position:center;color:#fff;text-shadow:0 1px 2px #000}
    .portal{
      position:absolute;width:26px;height:26px;border-radius:50%;background:radial-gradient(circle at 30% 30%, #8df,#15a);
      border:2px solid #fff;box-shadow:0 0 10px #8df;z-index:7;cursor:pointer;transform-origin:center
    }

    #ctx{position:absolute;z-index:50;background:#1b1a22;border:1px solid var(--accent);border-radius:8px;overflow:hidden;display:none;min-width:180px}
    #ctx button{display:block;width:100%;text-align:left;padding:.5rem .7rem;background:transparent;color:var(--ink);border:none;cursor:pointer}
    #ctx button:hover{background:rgba(255,255,255,.08)}

    #submap-overlay{position:absolute;inset:0;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);display:none;z-index:30}
    .parchment{position:absolute;inset:6% 10%;background:var(--paper) url('https://i.imgur.com/2mJvRjF.png') center/cover no-repeat;
      box-shadow:0 20px 60px rgba(0,0,0,.6);border:2px solid var(--paperEdge);border-radius:14px;overflow:hidden}
    .parchment .head{display:flex;justify-content:space-between;align-items:center;padding:.4rem .6rem;background:linear-gradient(#f6eed9,#eadfbf);border-bottom:1px solid var(--paperEdge)}
    .parchment .head .ttl{font-family:'Cinzel',serif;color:#5a4829}
    .parchment .head .x{background:#7a1;color:#fff;border:none;padding:.3rem .55rem;border-radius:999px;cursor:pointer}
    .parchment .body{position:absolute;inset:42px 8px 8px 8px;background:#d7ccb0}
    #submap-canvas{position:absolute;inset:0}

    #token-forge{flex:1;overflow:auto}
    #forge-grid{display:grid;grid-template-columns:1fr;gap:.6rem}
    #saved-maps{max-height:160px;overflow:auto;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:.35rem}
    .map-item{display:flex;align-items:center;gap:.5rem;margin:.3rem 0}
    .thumb{width:42px;height:42px;background:#222;border:1px solid rgba(255,255,255,.12);background-size:cover;background-position:center;border-radius:6px}
    #initiative{margin-top:auto}

    .handle{position:absolute;width:10px;height:10px;border:2px solid #00c8ff;background:#00131a;border-radius:2px;z-index:9;pointer-events:auto}

    .ov-box{border:1px solid var(--paperEdge);border-radius:10px;background:rgba(235,220,185,.07);padding:.6rem}
    .ov-row{display:grid;grid-template-columns:100px 1fr;gap:.5rem;align-items:center;margin:.35rem 0}
    #ov-console{min-height:70px;max-height:160px;overflow:auto;background:#0e0d12;border:1px dashed var(--accent);padding:.5rem;border-radius:8px;font-family:ui-monospace,SFMono-Regular,Consolas,Menlo,monospace;font-size:.85rem}

    /* Omniverse Help Popover */
    #ov-help{position:absolute;top:100%;left:50%;transform:translateX(-50%);width:420px;background:#14131a;border:1px solid var(--accent);border-radius:12px;
      color:var(--ink);font-size:.9rem;line-height:1.4;box-shadow:0 20px 50px rgba(0,0,0,.6);z-index:50;padding:1rem;display:none;}
    #ov-help::before{content:"";position:absolute;top:-10px;left:50%;transform:translateX(-50%);border:5px solid transparent;border-bottom:5px solid var(--accent);}
    #ov-help h4{color:var(--gold);margin:.2rem 0; font-size:1rem}
    #ov-help ul{margin:.5rem 0; padding-left:1.2rem }

    @media (max-width:1180px){
      #stage{grid-template-columns:0 1fr 360px}
      #left-panel{display:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="title">The War Vault</div>
      <div class="byline">Chris Marshall</div>
    </div>
    <div class="actions">
      <button id="btn-zoom-in" class="btn" type="button" title="Zoom in">Ôºã</button>
      <button id="btn-zoom-out" class="btn" type="button" title="Zoom out">Ôºç</button>
      <input id="map-upload" type="file" accept="image/*" class="btn" title="Upload map" />
      <button id="btn-save-map" class="btn" type="button" title="Save map">üíæ Save Map</button>
    </div>
  </header>

  <div id="stage">
    <aside id="left-panel">
      <div class="section" id="token-forge">
        <h3>Token Forge</h3>
        <div id="forge-grid">
          <div>
            <div class="row"><input id="tf-name" placeholder="Name" /></div>
            <div class="row"><label>Color</label><input id="tf-color" type="color" value="#ff4444" /></div>
            <div class="row"><label>Size (px)</label><input id="tf-size" type="number" min="24" max="120" value="42" /></div>
            <div class="row"><input id="tf-photo" type="file" accept="image/*" /></div>
            <div class="row"><input id="tf-model" type="file" accept=".glb,.gltf,model/*" /></div>
            <div class="row"><button id="btn-create-token" class="btn" type="button" style="width:100%">‚ûï Create Token</button></div>
          </div>
          <div>
            <div style="margin-bottom:.3rem;color:#cbb27d">Saved Maps</div>
            <div id="saved-maps"></div>
          </div>
        </div>
      </div>

      <div class="section" id="initiative">
        <h3>Initiative</h3>
        <div class="row">
          <input id="init-name" placeholder="Name">
          <input id="init-roll" type="number" placeholder="Roll" style="max-width:90px">
        </div>
        <div class="row"><button id="btn-init-add" class="btn" type="button" style="width:100%">Add</button></div>
        <div class="row" style="gap:.5rem">
          <button id="btn-init-next" class="btn" type="button" style="flex:1">Next</button>
          <button id="btn-init-reset" class="btn" type="button" style="flex:1">Reset</button>
        </div>
        <div id="init-list" style="margin-top:.5rem"></div>
      </div>
    </aside>

    <main id="map-container">
      <!-- 3D renderer canvas -->
      <canvas id="map3d"></canvas>

      <!-- hidden image (still used as the ‚Äúsource‚Äù for size) + legacy overlays -->
      <img id="map" src="https://i.imgur.com/8V7V3sP.jpg" alt="Map" />
      <canvas id="grid-layer"></canvas>
      <canvas id="template-layer"></canvas>
      <canvas id="fog-layer"></canvas>

      <div id="ctx">
        <button data-act="sheet" type="button">View Character Sheet</button>
        <button data-act="assign-submap" type="button">Assign Submap‚Ä¶</button>
        <button data-act="open-submap" type="button">Open Submap</button>
        <button data-act="delete" type="button">Delete Token</button>
      </div>

      <div id="submap-overlay">
        <div class="parchment">
          <div class="head">
            <div class="ttl" id="submap-title">Submap</div>
            <button class="x" id="close-submap" type="button">‚úï</button>
          </div>
          <div class="body"><canvas id="submap-canvas"></canvas></div>
        </div>
      </div>
    </main>

    <aside id="right-panel">
      <div class="section">
        <h3>Tools</h3>
        <div class="row" style="flex-wrap:wrap">
          <button class="btn tool" type="button" data-tool="pan">üñêÔ∏è Pan</button>
          <button class="btn tool" type="button" data-tool="select">üñ±Ô∏è Select</button>
          <button class="btn tool" type="button" data-tool="ruler">üìè Ruler</button>
          <button class="btn tool" type="button" data-tool="los">üéØ LOS</button>
          <button class="btn tool" type="button" data-tool="circle">‚≠ï Circle</button>
          <button class="btn tool" type="button" data-tool="rect">‚ñ≠ Rect</button>
          <button class="btn tool" type="button" data-tool="cone">üî∫ Cone</button>
          <button class="btn tool" type="button" data-tool="portal">üåÄ Portal</button>
        </div>
        <div class="row">
          <button id="btn-clear-templates" class="btn" type="button" style="flex:1">Clear Templates</button>
          <label style="display:flex;align-items:center;gap:.35rem"><input type="checkbox" id="snap" /> Snap-to-grid</label>
        </div>
        <div class="row">
          <select id="fog-mode">
            <option value="none">Fog: off</option>
            <option value="reveal">Fog: reveal</option>
            <option value="hide">Fog: hide</option>
          </select>
          <select id="brush">
            <option value="20">Brush 20</option>
            <option value="40" selected>Brush 40</option>
            <option value="80">Brush 80</option>
          </select>
        </div>
        <div class="row" style="gap:.5rem">
          <button id="btn-fog-undo" class="btn" type="button" style="flex:1">‚ü≤ Fog Undo</button>
          <button id="btn-fog-redo" class="btn" type="button" style="flex:1">‚ü≥ Fog Redo</button>
        </div>
      </div>

      <div class="section" id="submap-manager">
        <h3>Submap Manager</h3>
        <div class="row"><input type="file" id="submap-file" accept="image/*"></div>
        <div class="row"><input type="text" id="submap-name" placeholder="Name"></div>
        <div class="row"><button id="btn-add-submap" class="btn" type="button" style="width:100%">‚ûï Add Submap</button></div>
        <div id="submap-list"></div>
      </div>

      <div class="section">
        <h3>3D & Assets</h3>
        <div class="row"><input id="heightmap-upload" type="file" accept="image/*" /></div>
        <div class="row" style="gap:.5rem">
          <button id="btn-toggle-grid3d" class="btn" type="button" style="flex:1">Toggle 3D Grid</button>
          <input id="terrain-scale" type="number" min="0" max="200" value="20" title="Terrain Height Scale (units)" />
        </div>
      </div>

      <div class="section" id="omniverse-lab">
        <h3>Omniverse Lab (beta)</h3>
        <div class="ov-box">
          <div class="ov-row"><label for="ov-url">Nucleus URL</label><input id="ov-url" placeholder="omniverse://server/Projects/WarVault" /></div>
          <div class="ov-row"><label for="ov-usd">USD Path</label><input id="ov-usd" placeholder="/Scenes/Dungeon.usd" /></div>
          <div class="ov-row"><label for="ov-res">Resolution</label><input id="ov-res" placeholder="4096x3072" /></div>
          <div class="ov-row">
            <label for="ov-format">Format</label>
            <select id="ov-format"><option value="webp" selected>WebP</option><option value="png">PNG</option></select>
          </div>
          <div class="row" style="gap:.5rem;flex-wrap:wrap">
            <button id="ov-connect" class="btn" type="button">üîó Connect</button>
            <button id="ov-generate" class="btn" type="button">‚ú® Generate Map</button>
            <button id="ov-refresh" class="btn" type="button">‚Üª Refresh</button>
            <button id="ov-open-library" class="btn" type="button">üìÇ Open Library</button>
            <button id="ov-help-btn" class="btn" type="button" style="padding:0.35rem 0.5rem; font-size:0.8rem">?</button>
          </div>
          <div id="ov-console" aria-live="polite">Omniverse console ready.</div>
        </div>
      </div>
    </aside>
  </div>

  <!-- Omniverse Help Popover -->
  <div id="ov-help">
    <h4>How to Use Omniverse</h4>
    <p>To connect your battlemap to NVIDIA Omniverse:</p>
    <ul>
      <li>Enter your <strong>Nucleus URL</strong> (e.g. <code>omniverse://your-server</code>)</li>
      <li>Set the <strong>USD Path</strong> to your scene</li>
      <li>Click <strong>Connect</strong> to sync</li>
      <li>Use <strong>Generate Map</strong> to pull terrain, lighting, and props</li>
    </ul>
    <p>Ensure Omniverse is running and accessible.</p>
  </div>

  <script>
    window.onload = function () {
      /* Element refs (2D helpers kept) */
      const wrap = document.getElementById('map-container');
      const mapEl = document.getElementById('map');           // source image only
      const grid = document.getElementById('grid-layer');
      const tpl  = document.getElementById('template-layer');
      const fog  = document.getElementById('fog-layer');
      const gctx = grid.getContext('2d');
      const tctx = tpl.getContext('2d');
      const fctx = fog.getContext('2d');

      /* Header actions */
      const zoomInBtn  = document.getElementById('btn-zoom-in');
      const zoomOutBtn = document.getElementById('btn-zoom-out');
      const mapUpload  = document.getElementById('map-upload');
      const saveMapBtn = document.getElementById('btn-save-map');

      /* Tools & fog controls */
      const toolButtons = Array.from(document.querySelectorAll('.tool'));
      const snapChk = document.getElementById('snap');
      const fogModeSel = document.getElementById('fog-mode');
      const brushSel = document.getElementById('brush');
      const clearTplBtn = document.getElementById('btn-clear-templates');
      const fogUndoBtn = document.getElementById('btn-fog-undo');
      const fogRedoBtn = document.getElementById('btn-fog-redo');

      const ctxMenu = document.getElementById('ctx');

      /* Token Forge */
      const tfName  = document.getElementById('tf-name');
      const tfColor = document.getElementById('tf-color');
      const tfSize  = document.getElementById('tf-size');
      const tfPhoto = document.getElementById('tf-photo');
      const tfModel = document.getElementById('tf-model');
      const createTokenBtn = document.getElementById('btn-create-token');
      const savedMapsDiv = document.getElementById('saved-maps');

      /* Submaps */
      const subFile = document.getElementById('submap-file');
      const subName = document.getElementById('submap-name');
      const subAddBtn = document.getElementById('btn-add-submap');
      const subList = document.getElementById('submap-list');

      /* Initiative */
      const initName = document.getElementById('init-name');
      const initRoll = document.getElementById('init-roll');
      const initAdd = document.getElementById('btn-init-add');
      const initNext = document.getElementById('btn-init-next');
      const initReset = document.getElementById('btn-init-reset');
      const initList = document.getElementById('init-list');

      /* 3D controls */
      const heightmapUpload = document.getElementById('heightmap-upload');
      const btnGrid3D = document.getElementById('btn-toggle-grid3d');
      const terrainScaleInput = document.getElementById('terrain-scale');

      /* Omniverse controls */
      const ovUrl = document.getElementById('ov-url');
      const ovUsd = document.getElementById('ov-usd');
      const ovRes = document.getElementById('ov-res');
      const ovFormat = document.getElementById('ov-format');
      const ovConnect = document.getElementById('ov-connect');
      const ovGenerate = document.getElementById('ov-generate');
      const ovRefresh = document.getElementById('ov-refresh');
      const ovOpenLibrary = document.getElementById('ov-open-library');
      const ovConsole = document.getElementById('ov-console');
      const ovHelpBtn = document.getElementById('ov-help-btn');
      const ovHelp = document.getElementById('ov-help');

      /* State */
      const cell = 50; // 50 px per grid cell
      let tokens = [];            // legacy DOM tokens list (kept for ctx menu); 3D tokens tracked separately
      let portals = [];
      let templates = [];         // store shapes {type, x,y,w,h, angle, isWall?:true}
      let selectedToken = null;

      let submaps = JSON.parse(localStorage.getItem('warvault-submaps') || '[]');
      let savedMaps = JSON.parse(localStorage.getItem('warvault-maps') || '[]');

      const FOG_LIMIT = 15;
      let fogUndoStack = [], fogRedoStack = [];
      let paintingFog = false, beganStroke = false;

      /* =========================
         3D ENGINE (Three.js)
      ==========================*/
      const { THREE, OrbitControls, GLTFLoader } = window;
      const canvas3d = document.getElementById('map3d');
      const renderer = new THREE.WebGLRenderer({ canvas: canvas3d, antialias:true, alpha:true });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(wrap.clientWidth, wrap.clientHeight);
      renderer.shadowMap.enabled = true;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, wrap.clientWidth/wrap.clientHeight, 0.1, 5000);
      camera.position.set(0, 600, 700);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0,0,0);

      // Lights
      scene.add(new THREE.HemisphereLight(0xffffff, 0x313131, 0.75));
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(400, 800, 300); dir.castShadow = true; dir.shadow.mapSize.set(2048,2048);
      scene.add(dir);

      // Ground (map) + grid + heightmap support
      const texLoader = new THREE.TextureLoader();
      const gltfLoader = new GLTFLoader();
      let mapMesh = null, grid3D = null;
      const world = { width: 100, height: 100, pxPerUnit: cell }; // 1 world unit == 1 cell

      function fitCamera() {
        const d = Math.max(world.width, world.height);
        camera.position.set(0, d*0.9, d*0.9);
        controls.target.set(0,0,0);
        controls.update();
      }

      async function setMapPlaneFrom(src){
        const tex = await texLoader.loadAsync(src);
        const imgW = tex.image.width, imgH = tex.image.height;
        world.width  = Math.max(1, Math.round(imgW / world.pxPerUnit));
        world.height = Math.max(1, Math.round(imgH / world.pxPerUnit));

        const geo = new THREE.PlaneGeometry(world.width, world.height, 256, 256); // dense enough for displacement
        const mat = new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide, displacementScale: 0 });
        if(mapMesh) scene.remove(mapMesh);
        mapMesh = new THREE.Mesh(geo, mat);
        mapMesh.rotation.x = -Math.PI/2; mapMesh.receiveShadow = true; mapMesh.name='ground';
        scene.add(mapMesh);

        if(grid3D) scene.remove(grid3D);
        grid3D = new THREE.GridHelper(Math.max(world.width, world.height), Math.max(world.width, world.height), 0x886622, 0x553311);
        scene.add(grid3D);
        fitCamera();
      }

      // Heightmap -> set displacementMap on material
      function applyHeightmap(imageBitmap, scale=20){
        if(!mapMesh) return;
        const tex = new THREE.CanvasTexture(imageBitmap);
        tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        mapMesh.material.displacementMap = tex;
        mapMesh.material.displacementScale = Number(scale) || 0;
        mapMesh.material.needsUpdate = true;
      }

      // Fog of War in 3D: mirror fog canvas on a plane slightly above ground
      let fogPlane = null, fogTex = null;
      function ensureFog3D(){
        if(!mapMesh) return;
        if(!fogTex){
          fogTex = new THREE.CanvasTexture(fog);
          fogTex.needsUpdate = true;
        }
        if(!fogPlane){
          const geo = new THREE.PlaneGeometry(world.width, world.height);
          const mat = new THREE.MeshBasicMaterial({ map: fogTex, transparent:true, opacity:1, side:THREE.DoubleSide });
          fogPlane = new THREE.Mesh(geo, mat);
          fogPlane.rotation.x = -Math.PI/2;
          fogPlane.position.y = 0.01; // float above ground
          scene.add(fogPlane);
        }
      }
      function syncFog3D(){
        if(!fogTex) return;
        fogTex.needsUpdate = true;
      }

      // 3D Tokens
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const planePick = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
      const tokenObjects = new Map(); // id -> Object3D

      function pxToWorld(px, py){
        return {
          x: (px / world.pxPerUnit) - world.width/2,
          z: (py / world.pxPerUnit) - world.height/2,
        };
      }
      function worldToPx(wx, wz){
        return {
          x: (wx + world.width/2) * world.pxPerUnit,
          y: (wz + world.height/2) * world.pxPerUnit,
        };
      }

      function spriteToken({ id, name, imageUrl, sizeCells=1 }){
        const tex = texLoader.load(imageUrl);
        const mat = new THREE.SpriteMaterial({ map: tex, depthTest:true, depthWrite:false });
        const spr = new THREE.Sprite(mat);
        spr.scale.set(sizeCells, sizeCells, 1);
        spr.position.set(0, 0.51, 0);
        spr.userData = { id, name, kind:'sprite', sizeCells };
        scene.add(spr);
        tokenObjects.set(id, spr);
        return spr;
      }
      async function modelToken({ id, name, glbUrl, sizeCells=1 }){
        const glb = await gltfLoader.loadAsync(glbUrl);
        const root = glb.scene;
        const box = new THREE.Box3().setFromObject(root);
        const sz = new THREE.Vector3(); box.getSize(sz);
        const scale = sizeCells / Math.max(sz.x || 1, sz.z || 1);
        root.scale.setScalar(scale);
        root.traverse(o=>{ if(o.isMesh){ o.castShadow = true; o.receiveShadow = true; }});
        root.position.set(0, 0, 0);
        root.userData = { id, name, kind:'glb', sizeCells };
        scene.add(root);
        tokenObjects.set(id, root);
        return root;
      }
      function tweenTo(obj, toVec3, secs=0.35){
        const from = obj.position.clone();
        const start = performance.now();
        function step(now){
          const t = Math.min(1, (now-start)/(secs*1000));
          obj.position.lerpVectors(from, toVec3, t);
          if(t<1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      }
      function getGroundPoint(clientX, clientY){
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((clientX - rect.left)/rect.width)*2 - 1;
        mouse.y = -((clientY - rect.top)/rect.height)*2 + 1;
        raycaster.setFromCamera(mouse, camera);
        return raycaster.ray.intersectPlane(planePick, new THREE.Vector3());
      }

      // Drag & click-to-move
      let dragToken = null, dragOffset = new THREE.Vector3();
      renderer.domElement.addEventListener('pointerdown', (e)=>{
        const p = getGroundPoint(e.clientX, e.clientY); if(!p) return;
        // hit test tokens
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(Array.from(tokenObjects.values()), true);
        if(hits.length){
          let obj = hits[0].object; while(obj && !obj.userData?.id) obj = obj.parent;
          dragToken = obj; dragOffset.copy(p).sub(dragToken.position);
          renderer.domElement.setPointerCapture(e.pointerId);
        } else if (selectedToken) {
          const dest = p.clone(); dest.y = selectedToken.position.y;
          if(snapChk.checked){ dest.x = Math.round(dest.x); dest.z = Math.round(dest.z); }
          tweenTo(selectedToken, dest, 0.35);
        }
      });
      renderer.domElement.addEventListener('pointermove', (e)=>{
        if(!dragToken) return;
        const p = getGroundPoint(e.clientX, e.clientY); if(!p) return;
        const newPos = p.clone().sub(dragOffset); newPos.y = dragToken.position.y;
        if(snapChk.checked){ newPos.x = Math.round(newPos.x); newPos.z = Math.round(newPos.z); }
        dragToken.position.copy(newPos);
      });
      renderer.domElement.addEventListener('pointerup', (e)=>{
        if(dragToken){ selectedToken = dragToken; dragToken = null; renderer.domElement.releasePointerCapture(e.pointerId); }
      });

      // Public helpers
      function addToken3DFromForge(token){
        const id = token.id || Math.random().toString(36).slice(2);
        const sizeCells = Math.max(1, Math.round((token.size||50) / cell));
        if(token.glbUrl){
          modelToken({ id, name: token.name||'Token', glbUrl: token.glbUrl, sizeCells }).then(()=>select3D(id));
        } else if(token.photo){
          spriteToken({ id, name: token.name||'Token', imageUrl: token.photo, sizeCells }); select3D(id);
        } else {
          const svg = `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256'><circle cx='128' cy='128' r='120' fill='${encodeURIComponent(token.color||"#ff4444")}' stroke='white' stroke-width='10'/><text x='50%' y='54%' text-anchor='middle' font-family='sans-serif' font-size='90' fill='black'>${(token.name||"T")[0]}</text></svg>`;
          spriteToken({ id, name: token.name||'Token', imageUrl: svg, sizeCells }); select3D(id);
        }
        return id;
      }
      function moveTokenPx3D(id, px, py){
        const obj = tokenObjects.get(id); if(!obj) return;
        const w = pxToWorld(px, py);
        tweenTo(obj, new THREE.Vector3(w.x, obj.position.y, w.z), 0.3);
      }
      function getTokenPx3D(id){
        const obj = tokenObjects.get(id); if(!obj) return null;
        return worldToPx(obj.position.x, obj.position.z);
      }
      function select3D(id){ selectedToken = tokenObjects.get(id) || null; }

      // LOS: raycast between two points, block by ‚Äúwall‚Äù templates (rects)
      function losClear(fromPx, toPx){
        // Build simple wall AABBs in world units
        const walls = templates.filter(t=>t.isWall && t.type==='rect').map(t=>{
          const a = pxToWorld(t.x, t.y), b = pxToWorld(t.x + t.w, t.y + t.h);
          const min = new THREE.Vector3(Math.min(a.x,b.x), 0, Math.min(a.z,b.z));
          const max = new THREE.Vector3(Math.max(a.x,b.x), 4, Math.max(a.z,b.z)); // thin wall height
          return new THREE.Box3(min,max);
        });
        const A = pxToWorld(fromPx.x, fromPx.y); const B = pxToWorld(toPx.x, toPx.y);
        // Sample along the segment; if any point goes ‚Äúinside‚Äù a wall, LOS blocked
        const steps = 64;
        for(let i=0;i<=steps;i++){
          const t=i/steps; const x=A.x*(1-t)+B.x*t, z=A.z*(1-t)+B.z*t;
          const p = new THREE.Vector3(x,1,z);
          for(const w of walls){ if(w.containsPoint(p)) return false; }
        }
        return true;
      }

      // A* pathfinding (grid in world units; walls from templates)
      function pathfindPx(startPx, goalPx){
        const cols = Math.max(2, Math.round(world.width));
        const rows = Math.max(2, Math.round(world.height));
        const start = { cx: Math.round((startPx.x/world.pxPerUnit)), cy: Math.round((startPx.y/world.pxPerUnit)) };
        const goal  = { cx: Math.round((goalPx.x/world.pxPerUnit)),  cy: Math.round((goalPx.y/world.pxPerUnit)) };
        // blocked cells
        const blocked = new Set();
        templates.filter(t=>t.isWall && t.type==='rect').forEach(t=>{
          const x0=Math.floor(t.x/world.pxPerUnit), y0=Math.floor(t.y/world.pxPerUnit);
          const x1=Math.ceil((t.x+t.w)/world.pxPerUnit), y1=Math.ceil((t.y+t.h)/world.pxPerUnit);
          for(let y=y0;y<=y1;y++) for(let x=x0;x<=x1;x++) blocked.add(`${x},${y}`);
        });
        function h(a,b){ return Math.abs(a.cx-b.cx)+Math.abs(a.cy-b.cy); }
        const open=[start], came={}, g={}, f={};
        const key=(n)=>`${n.cx},${n.cy}`;
        g[key(start)]=0; f[key(start)]=h(start,goal);
        const deltas=[[1,0],[-1,0],[0,1],[0,-1]];
        while(open.length){
          open.sort((A,B)=> (f[key(A)]??1e9)-(f[key(B)]??1e9));
          const current=open.shift(); if(current.cx===goal.cx && current.cy===goal.cy){
            const path=[goal]; let cur=key(goal);
            while(came[cur]){ const n=came[cur]; path.push(n); cur=key(n); }
            path.reverse();
            // convert to px waypoints
            return path.map(n=>({ x: n.cx*world.pxPerUnit, y: n.cy*world.pxPerUnit }));
          }
          for(const [dx,dy] of deltas){
            const nx={cx: current.cx+dx, cy: current.cy+dy};
            if(nx.cx<0||nx.cy<0||nx.cx>cols||nx.cy>rows) continue;
            if(blocked.has(key(nx))) continue;
            const tg = (g[key(current)]??1e9) + 1;
            if(tg < (g[key(nx)]??1e9)){
              came[key(nx)] = current;
              g[key(nx)] = tg;
              f[key(nx)] = tg + h(nx,goal);
              if(!open.find(n=>n.cx===nx.cx && n.cy===nx.cy)) open.push(nx);
            }
          }
        }
        return null; // no path
      }

      // Resize + render loop
      function onResize(){
        const r = wrap.getBoundingClientRect();
        renderer.setSize(r.width, r.height);
        camera.aspect = r.width / r.height; camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', onResize);
      (function animate(){ controls.update(); renderer.render(scene,camera); requestAnimationFrame(animate); })();

      /* =========================
         2D helper layers (grid/fog/templates)
      ==========================*/
      function fitCanvases() {
        const r = wrap.getBoundingClientRect();
        [grid, tpl, fog].forEach(cv => { cv.width = r.width; cv.height = r.height; });
        drawGrid2D();
        redrawTemplates();
        if (!fogUndoStack.length) { fctx.clearRect(0,0,fog.width,fog.height); pushFogState(); }
        ensureFog3D(); syncFog3D();
      }
      let resizeRAF = 0;
      window.addEventListener('resize', () => { cancelAnimationFrame(resizeRAF); resizeRAF = requestAnimationFrame(fitCanvases); });
      fitCanvases();

      function drawGrid2D() {
        const step = (cell / world.pxPerUnit) * (grid.width / world.width); // scale grid to canvas
        gctx.clearRect(0,0,grid.width,grid.height);
        gctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--rune'); gctx.lineWidth=1;
        for (let x = 0; x < grid.width; x += step) { gctx.beginPath(); gctx.moveTo(x, 0); gctx.lineTo(x, grid.height); gctx.stroke(); }
        for (let y = 0; y < grid.height; y += step) { gctx.beginPath(); gctx.moveTo(0, y); gctx.lineTo(grid.width, y); gctx.stroke(); }
      }

      function redrawTemplates(){
        tctx.clearRect(0,0,tpl.width,tpl.height);
        templates.forEach(t=>{
          tctx.save();
          tctx.globalAlpha = 0.9;
          tctx.strokeStyle = t.isWall ? '#ffb37a' : '#8ddcff';
          tctx.fillStyle   = t.isWall ? 'rgba(255,179,122,.15)' : 'rgba(141,220,255,.12)';
          if(t.type==='rect'){
            tctx.fillRect(t.x, t.y, t.w, t.h); tctx.strokeRect(t.x, t.y, t.w, t.h);
          }else if(t.type==='circle'){
            tctx.beginPath(); tctx.arc(t.x, t.y, t.r, 0, Math.PI*2); tctx.fill(); tctx.stroke();
          }
          tctx.restore();
        });
      }

      function pushFogState(){
        try {
          const img = fctx.getImageData(0,0,fog.width,fog.height);
          fogUndoStack.push(img); if(fogUndoStack.length>FOG_LIMIT) fogUndoStack.shift(); fogRedoStack=[];
        } catch(e){ console.warn('Fog undo failed (tainted canvas)'); }
      }
      const beginFogStroke=()=>{ paintingFog=true; beganStroke=false; };
      const endFogStroke=()=>{ paintingFog=false; pushFogState(); syncFog3D(); };

      function paintFog(sx,sy,reveal){
        if(!beganStroke){ pushFogState(); beganStroke=true; }
        fctx.globalCompositeOperation = reveal ? 'destination-out' : 'source-over';
        if(!reveal) fctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--mist');
        const r = parseInt(brushSel.value,10);
        fctx.beginPath(); fctx.arc(sx,sy,r,0,Math.PI*2); fctx.fill();
        fctx.globalCompositeOperation = 'source-over';
        syncFog3D();
      }

      // Fog pointer handlers (on fog canvas)
      fog.addEventListener('pointerdown', (e)=>{ if(fogModeSel.value==='none') return; beginFogStroke(); paintFog(e.offsetX,e.offsetY, fogModeSel.value==='reveal'); });
      fog.addEventListener('pointermove', (e)=>{ if(!paintingFog) return; paintFog(e.offsetX,e.offsetY, fogModeSel.value==='reveal'); });
      window.addEventListener('pointerup', endFogStroke);

      fogUndoBtn.addEventListener('click', ()=>{
        if(fogUndoStack.length<2) return;
        const prev=fogUndoStack.pop(); fogRedoStack.push(fctx.getImageData(0,0,fog.width,fog.height));
        try{ fctx.putImageData(prev,0,0); syncFog3D(); }catch(e){ console.warn('Fog undo failed'); }
      });
      fogRedoBtn.addEventListener('click', ()=>{
        if(!fogRedoStack.length) return;
        const img=fogRedoStack.pop(); fogUndoStack.push(fctx.getImageData(0,0,fog.width,fog.height));
        try{ fctx.putImageData(img,0,0); syncFog3D(); }catch(e){ console.warn('Fog redo failed'); }
      });

      /* =========================
         Map upload & zoom
      ==========================*/
      async function setMapSrc(src){
        // Update hidden img (for persistence/size), then 3D ground
        await new Promise((res)=>{ mapEl.onload=()=>res(); mapEl.src=src; });
        await setMapPlaneFrom(src);
        fitCanvases();
      }
      mapUpload.addEventListener('change', e=>{
        const file=e.target.files?.[0]; if(!file) return;
        const r=new FileReader(); r.onload=ev=>{ setMapSrc(ev.target.result); }; r.readAsDataURL(file);
      });

      zoomInBtn.addEventListener('click', ()=> controls.dollyIn(1.2));
      zoomOutBtn.addEventListener('click', ()=> controls.dollyOut(1.2));

      /* =========================
         Tools / templates (kept)
      ==========================*/
      let currentTool='pan';
      function setTool(t){ currentTool=t; toolButtons.forEach(b=>b.classList.toggle('toggled', b.dataset.tool===t)); }
      toolButtons.forEach(b=> b.addEventListener('click', ()=> setTool(b.dataset.tool)));
      setTool('pan');

      clearTplBtn.addEventListener('click', ()=>{ templates=[]; redrawTemplates(); });

      // Example: add ‚Äúwall rect‚Äù by dragging with Rect tool while holding Alt
      let rectStart=null;
      tpl.addEventListener('pointerdown', (e)=>{
        if(currentTool!=='rect') return;
        rectStart={x:e.offsetX,y:e.offsetY, wall:e.altKey};
      });
      tpl.addEventListener('pointermove', (e)=>{
        if(!rectStart||currentTool!=='rect') return;
        redrawTemplates();
        const w=e.offsetX-rectStart.x, h=e.offsetY-rectStart.y;
        tctx.setLineDash(rectStart.wall?[6,4]:[]); tctx.strokeStyle= rectStart.wall ? '#ffb37a' : '#8ddcff';
        tctx.strokeRect(rectStart.x, rectStart.y, w, h);
      });
      window.addEventListener('pointerup', (e)=>{
        if(!rectStart) return;
        const w=e.offsetX-rectStart.x, h=e.offsetY-rectStart.y;
        templates.push({type:'rect', x:rectStart.x, y:rectStart.y, w, h, isWall:!!rectStart.wall});
        rectStart=null; redrawTemplates();
      });

      // LOS tool demo: click two points on template layer to test LOS
      let losA=null;
      tpl.addEventListener('click', (e)=>{
        if(currentTool!=='los') return;
        const p={x:e.offsetX, y:e.offsetY};
        if(!losA){ losA=p; } else {
          const ok = losClear(losA, p);
          const msg = ok ? 'LOS: clear' : 'LOS: blocked';
          tctx.save(); tctx.strokeStyle = ok ? '#55ff8a' : '#ff6e6e'; tctx.lineWidth=2;
          tctx.beginPath(); tctx.moveTo(losA.x,losA.y); tctx.lineTo(p.x,p.y); tctx.stroke();
          tctx.restore();
          setTimeout(()=>redrawTemplates(), 900);
          losA=null;
        }
      });

      /* =========================
         Token Forge -> 3D tokens
      ==========================*/
      function fileToDataURL(file){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=e=>res(e.target.result); r.onerror=rej; r.readAsDataURL(file); }); }

      createTokenBtn.addEventListener('click', async ()=>{
        const name = tfName.value || 'Token';
        const color= tfColor.value || '#ff4444';
        const size = parseInt(tfSize.value,10) || 50;
        let photo=null, glbUrl=null;
        const imgFile=tfPhoto.files?.[0]; if(imgFile) photo = await fileToDataURL(imgFile);
        const mdlFile=tfModel.files?.[0]; if(mdlFile) glbUrl = await fileToDataURL(mdlFile);
        const id = addToken3DFromForge({name,color,size,photo,glbUrl});
        // Optionally place at center:
        // moveTokenPx3D(id, (world.width/2)*world.pxPerUnit, (world.height/2)*world.pxPerUnit);
      });

      /* =========================
         Heightmap upload (terrain)
      ==========================*/
      heightmapUpload.addEventListener('change', async (e)=>{
        const file=e.target.files?.[0]; if(!file) return;
        const bmp = await createImageBitmap(file);
        applyHeightmap(bmp, Number(terrainScaleInput.value||20));
      });
      terrainScaleInput.addEventListener('change', ()=> {
        if(mapMesh && mapMesh.material.displacementMap){
          mapMesh.material.displacementScale = Number(terrainScaleInput.value||20);
          mapMesh.material.needsUpdate = true;
        }
      });
      btnGrid3D.addEventListener('click', ()=> { if(grid3D) grid3D.visible = !grid3D.visible; });

      /* =========================
         Omniverse (unchanged plumbing)
      ==========================*/
      let ws=null;
      ovConnect.onclick = () => {
        if (!ovUrl.value || !ovUsd.value) return alert("Fill URL and USD path");
        ws = new WebSocket('ws://localhost:8080/omniverse');
        ws.onopen = () => { ws.send(JSON.stringify({ action: 'connect', url: ovUrl.value, usd: ovUsd.value })); logOv("Connected to Omniverse"); };
        ws.onmessage = (e) => {
          const msg = JSON.parse(e.data);
          if (msg.type === 'map') { setMapSrc(msg.image); logOv("Map received from Omniverse"); }
        };
        ws.onerror = () => logOv("Failed to connect to Omniverse");
      };
      ovGenerate.onclick = () => {
        if (ws?.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ action: 'generate', res: ovRes.value, format: ovFormat.value })); logOv("Generating map in Omniverse..."); }
        else { logOv("Not connected to Omniverse"); }
      };
      function logOv(msg){ ovConsole.innerHTML += `<div>${new Date().toLocaleTimeString()} ‚Äî ${msg}</div>`; ovConsole.scrollTop = ovConsole.scrollHeight; }
      ovHelpBtn.onclick = ()=>{ ovHelp.style.display = ovHelp.style.display === 'block' ? 'none' : 'block'; };
      document.addEventListener('click', (e)=>{ if (!ovHelp.contains(e.target) && e.target !== ovHelpBtn) ovHelp.style.display = 'none'; });

      /* =========================
         Init default map into 3D
      ==========================*/
      (async ()=>{ await setMapPlaneFrom(mapEl.src); fitCanvases(); ensureFog3D(); syncFog3D(); })();
    };
  </script>
</body>
</html>
