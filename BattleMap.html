<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The War Vault — Omniverse Edition (Stabilized)</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Great+Vibes&display=swap" rel="stylesheet">
<style>
  :root{
    --gold:#e6c57f;--accent:#b88c5c;--ink:#eee;--panel:#14131a;--mist:rgba(0,0,0,.55);--rune:rgba(230,197,127,.28);
    --paper:#f4ecd7;--paperEdge:#c9b27a;
  }
  *{box-sizing:border-box}
  body{
    margin:0;height:100vh;display:flex;flex-direction:column;background:#000;color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",sans-serif;overflow:hidden
  }

  /* Atmospheric background */
  body::before{
    content:"";
    position:fixed; inset:-10%;
    background:
      radial-gradient(60% 60% at 16% 10%, rgba(230,197,127,.10), transparent 60%),
      radial-gradient(55% 55% at 82% 0%, rgba(142,114,79,.08), transparent 60%),
      radial-gradient(50% 45% at 50% 100%, rgba(184,140,92,.08), transparent 55%),
      var(--bg-art),
      linear-gradient(180deg,#0b0a10 0%, #0b0a10 40%, #0a0a12 100%);
    background-size:auto,auto,auto,cover,100% 100%;
    filter:saturate(110%) contrast(102%);
    z-index:-2;
  }

  /* Film grain overlay */
  body::after{
    content:""; position:fixed; inset:0; pointer-events:none; z-index:-1;
    background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/><feColorMatrix type='saturate' values='0'/></filter><rect width='100%' height='100%' filter='url(%23n)' opacity='0.55'/></svg>");
    opacity:var(--grain-strength, .12);
    mix-blend-mode:overlay;
  }
  @media (prefers-reduced-motion: no-preference){
    body::after{ animation: grainShift 8s linear infinite; }
  }
  @keyframes grainShift{ from{ transform:translate3d(0,0,0);} to{ transform:translate3d(-160px,-160px,0);} }

  header{
    display:flex;align-items:center;justify-content:space-between;padding:.6rem 1rem;
    border-bottom:1px solid var(--accent);background:rgba(10,10,14,.9);backdrop-filter:blur(6px);
    position:relative;z-index:20;
    box-shadow: 0 2px 20px rgba(230,197,127,.06);
  }
  .brand{display:flex;flex-direction:column}
  .brand .title{
    font-family:'Cinzel',serif;font-weight:900;letter-spacing:.06em;color:var(--gold);
    text-shadow:0 0 12px rgba(230,197,127,.35);font-size:1.4rem
  }
  .brand .byline{font-family:'Great Vibes',cursive;font-size:1.5rem;line-height:1;color:var(--gold)}
  .actions{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  .btn{
    background:rgba(35,35,45,.85);border:1px solid var(--accent);color:var(--ink);
    padding:.35rem .6rem;border-radius:8px;cursor:pointer
  }
  .btn:hover{background:var(--accent);color:#000;box-shadow:0 0 14px rgba(230,197,127,.35)}
  .btn.toggled{background:var(--accent);color:#000}
  input,select{
    background:#1c1b24;border:1px solid var(--accent);color:var(--ink);
    padding:.35rem;border-radius:6px;width:100%
  }

  #stage{flex:1;display:grid;grid-template-columns:320px 1fr 360px;min-height:0}
  #left-panel{
    background:var(--panel);border-right:1px solid var(--accent);overflow:auto;display:flex;flex-direction:column;
    box-shadow: inset 0 0 0 1px rgba(184,140,92,.22), inset 0 0 24px rgba(230,197,127,.06);
  }
  #right-panel{
    background:var(--panel);border-left:1px solid var(--accent);overflow:auto;
    box-shadow: inset 0 0 0 1px rgba(184,140,92,.22), inset 0 0 24px rgba(230,197,127,.06);
  }
  #map-container{position:relative;overflow:hidden;background:#111}

  .section{padding:12px;border-bottom:1px solid rgba(255,255,255,.06);position:relative;background:linear-gradient(180deg, rgba(235,220,185,.05), transparent 40%)}
  .section h3{margin:.1rem 0 .6rem;font-family:'Cinzel',serif;color:var(--gold);font-size:1rem;position:relative;padding-bottom:.35rem}
  .section h3::after{content:"";display:block;height:10px;margin:.35rem 0 0;background:radial-gradient(closest-side, var(--gold), transparent) left / 12px 10px no-repeat,radial-gradient(closest-side, var(--gold), transparent) right / 12px 10px no-repeat,linear-gradient(to right, transparent 0%, var(--gold) 15%, var(--gold) 85%, transparent 100%);opacity:.45}
  .row{display:flex;gap:.5rem;align-items:center;margin:.4rem 0}
  .row.stacked{flex-direction:column;align-items:stretch}

  #map{
    position:absolute;inset:0;object-fit:contain;width:100%;height:100%;
    transform-origin:top left;cursor:grab;z-index:1
  }

  /* Overlay layers (all are transformed with the map so fog/grid track pan/zoom) */
  canvas, .portal{position:absolute;left:0;top:0;pointer-events:none}
  #fx-layer{z-index:2}
  #grid-layer{z-index:3}
  #template-layer{z-index:4}
  #walls-layer{z-index:5}
  #fog-layer{z-index:6} /* keep fog below tokens */
  .token{
    position:absolute;border-radius:50%;background:#f44;color:#000;font-weight:800;
    display:flex;align-items:center;justify-content:center;user-select:none;cursor:grab;
    z-index:7;border:2px solid #fff;transform-origin:center;overflow:hidden
  }
  .token span{pointer-events:none}
  .token.has-img{background-size:cover;background-position:center;color:#fff;text-shadow:0 1px 2px #000}

  /* Portal */
  .portal{
    z-index:8; /* above fog */
    border:3px solid var(--gold);
    background:transparent;
    box-shadow:0 0 14px rgba(230,197,127,.35), inset 0 0 12px rgba(230,197,127,.18);
    border-radius:6px;
    pointer-events:auto; /* to catch right-click */
    transform-origin:top left;
  }

  #ctx{
    position:absolute;z-index:50;background:#1b1a22;border:1px solid var(--accent);
    border-radius:8px;overflow:hidden;display:none;min-width:200px
  }
  #ctx button{display:block;width:100%;text-align:left;padding:.5rem .7rem;background:transparent;color:var(--ink);border:none;cursor:pointer}
  #ctx button:hover{background:rgba(255,255,255,.08)}

  #submap-overlay{
    position:absolute;inset:0;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);display:none;z-index:30
  }
  .parchment{
    position:absolute;inset:6% 10%;background:var(--paper) url('https://i.imgur.com/2mJvRjF.png') center/cover no-repeat;
    box-shadow:0 20px 60px rgba(0,0,0,.6);border:2px solid var(--paperEdge);border-radius:14px;overflow:hidden
  }
  .parchment .head{
    display:flex;justify-content:space-between;align-items:center;padding:.4rem .6rem;
    background:linear-gradient(#f6eed9,#eadfbf);border-bottom:1px solid var(--paperEdge)
  }
  .parchment .head .ttl{font-family:'Cinzel',serif;color:#5a4829}
  .parchment .head .x{background:#7a1;color:#fff;border:none;padding:.3rem .55rem;border-radius:999px;cursor:pointer}
  .parchment .body{position:absolute;inset:42px 8px 8px 8px;background:#d7ccb0}
  #submap-canvas{position:absolute;inset:0}

  #token-forge{flex:1;overflow:auto}
  #forge-grid{display:grid;grid-template-columns:1fr;gap:.6rem}
  #saved-maps{
    max-height:200px;overflow:auto;border:1px solid rgba(255,255,255,.12);
    border-radius:8px;padding:.35rem
  }
  .map-item{display:flex;align-items:center;gap:.5rem;margin:.3rem 0}
  .thumb{width:42px;height:42px;background:#222;border:1px solid rgba(255,255,255,.12);background-size:cover;background-position:center;border-radius:6px}
  #initiative{margin-top:auto}

  .handle{position:absolute;width:10px;height:10px;border:2px solid #00c8ff;background:#00131a;border-radius:2px;z-index:9;pointer-events:auto}

  .ov-box{border:1px solid var(--paperEdge);border-radius:10px;background:rgba(235,220,185,.07);padding:.6rem}
  .ov-row{display:grid;grid-template-columns:100px 1fr;gap:.5rem;align-items:center;margin:.35rem 0}
  #ov-console{
    min-height:70px;max-height:160px;overflow:auto;background:#0e0d12;border:1px dashed var(--accent);
    padding:.5rem;border-radius:8px;font-family:ui-monospace,SFMono-Regular,Consolas,Menlo,monospace;font-size:.85rem
  }

  /* Previous Renders modal */
  #renders-modal{
    position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:60
  }
  #renders-dialog{
    width:min(920px,90vw);max-height:80vh;overflow:auto;background:#14131a;border:1px solid var(--accent);border-radius:12px;
    box-shadow:0 30px 80px rgba(0,0,0,.65);padding:12px
  }
  .rl-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
  @media (max-width:980px){ .rl-grid{grid-template-columns:repeat(2,1fr)} }
  @media (max-width:620px){ .rl-grid{grid-template-columns:1fr} }
  .rl-card{border:1px solid rgba(255,255,255,.12);border-radius:10px;overflow:hidden;background:#0f0f14}
  .rl-shot{height:160px;background:#222 center/cover no-repeat}
  .rl-meta{padding:.5rem;border-top:1px solid rgba(255,255,255,.06)}
  .rl-actions{display:flex;gap:.4rem;padding:.5rem;border-top:1px solid rgba(255,255,255,.06)}

  /* Help popover */
  #ov-help{
    position:absolute;top:100%;left:50%;transform:translateX(-50%);
    width:420px;background:#14131a;border:1px solid var(--accent);border-radius:12px;
    color:var(--ink);font-size:.9rem;line-height:1.4;box-shadow:0 20px 50px rgba(0,0,0,.6);
    z-index:50;padding:1rem;display:none;
  }
  #ov-help::before{
    content:"";position:absolute;top:-10px;left:50%;transform:translateX(-50%);
    border:5px solid transparent;border-bottom:5px solid var(--accent);
  }
  #ov-help h4{color:var(--gold);margin:.2rem 0; font-size:1rem}
  #ov-help ul{margin:.5rem 0; padding-left:1.2rem }

  /* While painting fog, route pointer events to fog canvas */
  .fog-edit .token, .fog-edit .portal { pointer-events: none !important; }
  #fog-layer.fog-active { z-index: 100 !important; pointer-events: auto !important; }

  :root{ /* optional texture + UI tuning */
    --bg-art: url("assets/bg-etched-stone.webp");
    --bg-vignette: radial-gradient(65% 65% at 50% 55%, rgba(0,0,0,0) 55%, rgba(0,0,0,.6) 100%);
    --grain-strength: .12;
    /* inline SVG for gold frame */
    --gold-frame: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' preserveAspectRatio='none'><defs><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop offset='0' stop-color='%23e6c57f'/><stop offset='.5' stop-color='%23b88c5c'/><stop offset='1' stop-color='%237d5d38'/></linearGradient></defs><path d='M1,1 H11 V11 H1 Z' fill='none' stroke='url(%23g)' stroke-width='1.2'/></svg>");
  }

  /* Ornate gold border-image on main frames */
  #left-panel, #right-panel, #renders-dialog, .parchment{
    border:12px solid transparent;
    border-image-source: var(--gold-frame);
    border-image-slice: 4 fill;
    border-image-width: 12;
    border-image-repeat: stretch;
  }

  /* Subtle separators inside lists */
  .map-item{ position:relative; padding:6px 0; }
  .map-item + .map-item{ border-top:1px dashed rgba(255,255,255,.10); }

  /* Decorative parchment corners */
  .parchment::before,
  .parchment::after{
    content:""; position:absolute; width:36px; height:36px;
    background: radial-gradient(closest-side, rgba(0,0,0,.35), transparent 70%),
                conic-gradient(from 45deg, rgba(230,197,127,.55), transparent 75%);
    filter: blur(.3px); opacity:.6;
  }
  .parchment::before{ left:-10px; top:-10px; border-radius:12px; }
  .parchment::after{ right:-10px; bottom:-10px; border-radius:12px; transform: scaleX(-1) scaleY(-1); }

  @media (max-width:1180px){
    #stage{grid-template-columns:0 1fr 360px}
    #left-panel{display:none}
  }
</style>
<link rel="preload" as="image" href="assets/bg-etched-stone.webp" imagesizes="100vw">
</head>
<body>
<header>
  <div class="brand">
    <div class="title">The War Vault</div>
    <div class="byline">Chris Marshall</div>
  </div>
  <div class="actions" id="top-actions">
    <button id="btn-zoom-in" class="btn" type="button" title="Zoom in">＋</button>
    <button id="btn-zoom-out" class="btn" type="button" title="Zoom out">－</button>
    <input id="map-upload" type="file" accept="image/*" class="btn" title="Upload map" />
    <button id="btn-save-map" class="btn" type="button" title="Save map">💾 Save</button>
    <button id="btn-open-renders" class="btn" type="button" title="Previous renders">🖼️ Previous</button>
  </div>
</header>

<div id="stage">
  <aside id="left-panel">
    <div class="section" id="token-forge">
      <h3>Token Forge</h3>
      <div id="forge-grid">
        <div>
          <div class="row"><input id="tf-name" placeholder="Name" /></div>
          <div class="row">
            <label for="tf-color" style="min-width:60px">Color</label>
            <input id="tf-color" type="color" value="#ff4444" />
          </div>
          <div class="row">
            <label for="tf-size" style="min-width:60px">Size (px)</label>
            <input id="tf-size" type="number" min="24" max="120" value="42" />
          </div>
          <div class="row"><input id="tf-photo" type="file" accept="image/*" /></div>
          <div class="row"><button id="btn-create-token" class="btn" type="button" style="width:100%">➕ Create Token</button></div>
        </div>
        <div>
          <div style="margin-bottom:.3rem;color:#cbb27d">Saved Sessions</div>
          <div id="saved-maps"></div>
        </div>
      </div>
    </div>

    <div class="section" id="initiative">
      <h3>Initiative</h3>
      <div class="row">
        <input id="init-name" placeholder="Name" aria-label="Initiative name">
        <input id="init-roll" type="number" placeholder="Roll" style="max-width:90px" aria-label="Initiative roll">
      </div>
      <div class="row">
        <button id="btn-init-add" class="btn" type="button" style="width:100%">Add</button>
      </div>
      <div class="row" style="gap:.5rem">
        <button id="btn-init-next" class="btn" type="button" style="flex:1">Next</button>
        <button id="btn-init-reset" class="btn" type="button" style="flex:1">Reset</button>
      </div>
      <div id="init-list" style="margin-top:.5rem"></div>
    </div>
  </aside>

  <main id="map-container">
    <img id="map" src="https://i.imgur.com/8V7V3sP.jpg" alt="Map" />
    <canvas id="fx-layer"></canvas>
    <canvas id="grid-layer"></canvas>
    <canvas id="template-layer"></canvas>
    <canvas id="walls-layer"></canvas>
    <canvas id="fog-layer"></canvas>

    <div id="ctx" role="menu">
      <button data-act="sheet" type="button">View Character Sheet</button>
      <button data-act="assign-submap" type="button">Assign Submap…</button>
      <button data-act="open-submap" type="button">Open Submap</button>
      <button data-act="delete" type="button">Delete</button>
    </div>

    <div id="submap-overlay" aria-hidden="true">
      <div class="parchment" role="dialog" aria-modal="true" aria-labelledby="submap-title">
        <div class="head">
          <div class="ttl" id="submap-title">Submap</div>
          <button class="x" id="close-submap" type="button" aria-label="Close">✕</button>
        </div>
        <div class="body">
          <canvas id="submap-canvas"></canvas>
        </div>
      </div>
    </div>
  </main>

  <aside id="right-panel">
    <div class="section">
      <h3>Tools</h3>
      <div class="row" style="flex-wrap:wrap">
        <button class="btn tool" type="button" data-tool="pan">🖐️ Pan</button>
        <button class="btn tool" type="button" data-tool="select">🖱️ Select</button>
        <button class="btn tool" type="button" data-tool="ruler">📏 Ruler</button>
        <button class="btn tool" type="button" data-tool="circle">⭕ Circle</button>
        <button class="btn tool" type="button" data-tool="cone">🔺 Cone</button>
        <button class="btn tool" type="button" data-tool="wall">🧱 Wall</button>
        <button class="btn tool" type="button" data-tool="portal">🌀 Portal</button>
      </div>
      <div class="row">
        <button id="btn-clear-templates" class="btn" type="button" style="flex:1">Clear Templates</button>
        <label style="display:flex;align-items:center;gap:.35rem"><input type="checkbox" id="snap" /> Snap-to-grid</label>
      </div>
      <div class="row">
        <select id="fog-mode" aria-label="Fog mode">
          <option value="none">Fog: off</option>
          <option value="reveal">Fog: reveal</option>
          <option value="hide">Fog: hide</option>
        </select>
        <select id="brush" aria-label="Brush size">
          <option value="20">Brush 20</option>
          <option value="40" selected>Brush 40</option>
          <option value="80">Brush 80</option>
        </select>
      </div>
      <div class="row" style="gap:.5rem">
        <button id="btn-fog-undo" class="btn" type="button" style="flex:1">⟲ Fog Undo</button>
        <button id="btn-fog-redo" class="btn" type="button" style="flex:1">⟳ Fog Redo</button>
      </div>
    </div>

    <div class="section" id="submap-manager">
      <h3>Submap Manager</h3>
      <div class="row"><input type="file" id="submap-file" accept="image/*" aria-label="Submap image"></div>
      <div class="row"><input type="text" id="submap-name" placeholder="Name" aria-label="Submap name"></div>
      <div class="row"><button id="btn-add-submap" class="btn" type="button" style="width:100%">➕ Add Submap</button></div>
      <div id="submap-list"></div>
    </div>

    <div class="section" id="omniverse-lab">
      <h3>Omniverse Lab (beta)</h3>
      <div class="ov-box">
        <div class="ov-row">
          <label for="ov-url">Nucleus URL</label>
          <input id="ov-url" placeholder="omniverse://server/Projects/WarVault" />
        </div>
        <div class="ov-row">
          <label for="ov-usd">USD Path</label>
          <input id="ov-usd" placeholder="/Scenes/Dungeon.usd" />
        </div>
        <div class="ov-row">
          <label for="ov-res">Resolution</label>
          <input id="ov-res" placeholder="4096x3072" />
        </div>
        <div class="ov-row">
          <label for="ov-format">Format</label>
          <select id="ov-format">
            <option value="webp" selected>WebP</option>
            <option value="png">PNG</option>
          </select>
        </div>
        <div class="row" style="gap:.5rem;flex-wrap:wrap">
          <button id="ov-connect" class="btn" type="button">🔗 Connect</button>
          <button id="ov-generate" class="btn" type="button">✨ Generate Map</button>
          <button id="ov-refresh" class="btn" type="button">↻ Refresh</button>
          <button id="ov-open-library" class="btn" type="button">📂 Open Library</button>
          <button id="ov-help-btn" class="btn" type="button" style="padding:0.35rem 0.5rem; font-size:0.8rem">?</button>
        </div>
        <div id="ov-console" aria-live="polite">Omniverse console ready.</div>
      </div>
    </div>
  </aside>
</div>

<!-- Previous Renders Modal -->
<div id="renders-modal" role="dialog" aria-modal="true" aria-labelledby="renders-title">
  <div id="renders-dialog">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
      <h3 id="renders-title" style="margin:.2rem 0;font-family:'Cinzel',serif;color:var(--gold)">Previous Renders</h3>
      <button id="renders-close" class="btn" type="button">✕ Close</button>
    </div>
    <div id="renders-grid" class="rl-grid"></div>
  </div>
</div>

<!-- Omniverse Help Popover -->
<div id="ov-help">
  <h4>How to Use Omniverse</h4>
  <p>To connect your battlemap to NVIDIA Omniverse:</p>
  <ul>
    <li>Enter your <strong>Nucleus URL</strong> (e.g. <code>omniverse://your-server</code>)</li>
    <li>Set the <strong>USD Path</strong> to your scene</li>
    <li>Click <strong>Connect</strong> to sync</li>
    <li>Use <strong>Generate Map</strong> to pull terrain, lighting, and props</li>
  </ul>
  <p>Ensure Omniverse is running and accessible.</p>
</div>

<script>
window.onload = function () {
  /* Element refs */
  const wrap  = document.getElementById('map-container');
  const mapEl = document.getElementById('map');
  const fx    = document.getElementById('fx-layer');
  const grid  = document.getElementById('grid-layer');
  const tpl   = document.getElementById('template-layer');
  const wallsLayer = document.getElementById('walls-layer');
  const fog   = document.getElementById('fog-layer');

  const fxx = fx.getContext('2d');
  const gctx = grid.getContext('2d');
  const tctx = tpl.getContext('2d');
  const wctx = wallsLayer.getContext('2d');
  const fctx = fog.getContext('2d');

  const zoomInBtn  = document.getElementById('btn-zoom-in');
  const zoomOutBtn = document.getElementById('btn-zoom-out');
  const mapUpload  = document.getElementById('map-upload');
  const saveMapBtn = document.getElementById('btn-save-map');

  const toolButtons = Array.from(document.querySelectorAll('.tool'));
  const snapChk     = document.getElementById('snap');
  const fogModeSel  = document.getElementById('fog-mode');
  const brushSel    = document.getElementById('brush');
  const clearTplBtn = document.getElementById('btn-clear-templates');
  const fogUndoBtn  = document.getElementById('btn-fog-undo');
  const fogRedoBtn  = document.getElementById('btn-fog-redo');

  const ctxMenu = document.getElementById('ctx');

  const tfName  = document.getElementById('tf-name');
  const tfColor = document.getElementById('tf-color');
  const tfSize  = document.getElementById('tf-size');
  const tfPhoto = document.getElementById('tf-photo');
  const createTokenBtn = document.getElementById('btn-create-token');
  const savedMapsDiv   = document.getElementById('saved-maps');

  const subFile = document.getElementById('submap-file');
  const subName = document.getElementById('submap-name');
  const subAddBtn = document.getElementById('btn-add-submap');
  const subList   = document.getElementById('submap-list');

  const initName = document.getElementById('init-name');
  const initRoll = document.getElementById('init-roll');
  const initAdd  = document.getElementById('btn-init-add');
  const initNext = document.getElementById('btn-init-next');
  const initReset= document.getElementById('btn-init-reset');
  const initList = document.getElementById('init-list');

  /* Omniverse bits (bridge optional) */
  const ovUrl = document.getElementById('ov-url');
  const ovUsd = document.getElementById('ov-usd');
  const ovRes = document.getElementById('ov-res');
  const ovFormat = document.getElementById('ov-format');
  const ovConnect = document.getElementById('ov-connect');
  const ovGenerate= document.getElementById('ov-generate');
  const ovRefresh = document.getElementById('ov-refresh');
  const ovOpenLibrary = document.getElementById('ov-open-library');
  const ovConsole = document.getElementById('ov-console');
  const ovHelpBtn = document.getElementById('ov-help-btn');
  const ovHelp    = document.getElementById('ov-help');

  /* Previous Renders modal */
  const openRendersBtn = document.getElementById('btn-open-renders');
  const rendersModal   = document.getElementById('renders-modal');
  const rendersClose   = document.getElementById('renders-close');
  const rlGrid         = document.getElementById('renders-grid');

  /* Global state (world space == canvas CSS px at scale=1) */
  let scale = 1;
  let offset = { x: 0, y: 0 };
  const cell = 50;

  let tokens   = [];   // {el,name,color,size,x,y,img?, sheet?}
  let portals  = [];   // {el,x,y,w,h,targetName?}
  let templates= [];   // {type, ...}
  let walls    = [];   // {a:{x,y}, b:{x,y}, type, open}

  let submaps = JSON.parse(localStorage.getItem('warvault-submaps') || '[]');
  let sessions= JSON.parse(localStorage.getItem('warvault-maps')    || '[]');

  let currentTool = 'pan';

  // Unified action state to prevent conflicting listeners
  let action = null; // { type: 'pan'|'draw'|'token'|'portal'|'fog', ... }

  let selectedToken = null;
  let selectedPortal= null;
  let drawingWall = null; // {points:[], type}

  /* Fog-of-war in world space */
  let fogTex = document.createElement('canvas');
  let fogx   = fogTex.getContext('2d');
  const FOG_LIMIT = 20;
  let fogUndoStack = [];
  let fogRedoStack = [];

  /* FX */
  let noiseTile = null;

  /* Initiative */
  let initiative = [];
  let initIdx = -1;

  /* WebSocket bridge (optional) */
  let ws = null;

  /* ==== Helpers ==== */
  const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
  function screenToWorld(sx, sy)  { return { x: (sx - offset.x) / scale, y: (sy - offset.y) / scale }; }
  function worldToScreen(wx, wy)  { return { x: offset.x + wx * scale,   y: offset.y + wy * scale   }; }
  function snap(v) { return document.getElementById('snap').checked ? Math.round(v / cell) * cell : v; }
  function pointerToWrap(e){ const r = wrap.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }

  /* ==== Fit canvases (HiDPI) ==== */
  function fitCanvases() {
    const r = wrap.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

// Fog: Undo
fogUndoBtn.addEventListener('click', () => {
  if (fogUndoStack.length < 2) return;
  const prev = fogUndoStack.pop();
  try { fogRedoStack.push(fogx.getImageData(0,0,fogTex.width,fogTex.height)); } catch {}
  try { fogx.putImageData(prev,0,0); } catch {}
  drawFogToScreen();
});

    tctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    wctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    fctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    drawGrid();
    drawWalls();
    drawTemplates();
    drawFX();
    drawFogToScreen();
    repositionAll();
  }
  let resizeRAF = 0;
  window.addEventListener('resize', () => {
    cancelAnimationFrame(resizeRAF);
    resizeRAF = requestAnimationFrame(fitCanvases);
  });

  /* Grid */
  function drawGrid() {
    const dpr = window.devicePixelRatio || 1;
    const w = grid.width / dpr, h = grid.height / dpr;
    gctx.clearRect(0,0,w,h);
    gctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--rune');
    gctx.lineWidth = 1;
    const step = cell;
    for (let x=0; x<w; x+=step){ gctx.beginPath(); gctx.moveTo(x,0); gctx.lineTo(x,h); gctx.stroke(); }
    for (let y=0; y<h; y+=step){ gctx.beginPath(); gctx.moveTo(0,y); gctx.lineTo(w,y); gctx.stroke(); }
  }

  /* Background FX */
  function makeNoiseTile(){
    const c = document.createElement('canvas');
    c.width = c.height = 128;
    const x = c.getContext('2d');
    const img = x.createImageData(c.width, c.height);
    for (let i=0;i<img.data.length;i+=4){
      const v = 200 + Math.random()*55;
      img.data[i]=img.data[i+1]=img.data[i+2]=v;
      img.data[i+3]=10;
    }
    x.putImageData(img,0,0);
    return c;
  }
  function drawFX(){
    const w = fx.clientWidth, h = fx.clientHeight;
    fxx.clearRect(0,0,w,h);
    const g = fxx.createRadialGradient(w*0.5,h*0.55, Math.min(w,h)*0.15, w*0.5,h*0.55, Math.max(w,h)*0.65);
    g.addColorStop(0,'rgba(0,0,0,0)');
    g.addColorStop(1,'rgba(0,0,0,0.45)');
    fxx.globalCompositeOperation='multiply';
    fxx.fillStyle=g; fxx.fillRect(0,0,w,h);
    if(!noiseTile) noiseTile = makeNoiseTile();
    const p = fxx.createPattern(noiseTile,'repeat');
    fxx.globalCompositeOperation='overlay'; fxx.globalAlpha=0.35;
    fxx.fillStyle=p; fxx.fillRect(0,0,w,h);
    fxx.globalAlpha=1; fxx.globalCompositeOperation='source-over';
  }
  mapEl.style.filter = 'contrast(1.06) saturate(1.08) brightness(1.02)';

  /* Reposition (apply same transform to overlays so fog/grid/etc track) */
  function applyTransform(el){
    el.style.transform = `translate(${offset.x}px, ${offset.y}px) scale(${scale})`;
    el.style.transformOrigin = 'top left';
  }
  function repositionAll() {
    applyTransform(mapEl);
    [fx, grid, tpl, wallsLayer, fog].forEach(applyTransform);
    tokens.forEach(t=>{
      const s = worldToScreen(t.x, t.y);
      t.el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
      t.el.style.transformOrigin = 'top left';
    });
    portals.forEach(p=>{
      const s = worldToScreen(p.x, p.y);
      p.el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
      p.el.style.width = p.w + 'px';
      p.el.style.height= p.h + 'px';
    });
  }

  /* Zoom */
  function setScale(newScale, anchorX, anchorY) {
    const old = scale;
    scale = clamp(newScale, 0.2, 6);
    const ax = anchorX ?? grid.clientWidth / 2;
    const ay = anchorY ?? grid.clientHeight / 2;
    const wx = (ax - offset.x) / old;
    const wy = (ay - offset.y) / old;
    offset.x = ax - wx * scale;
    offset.y = ay - wy * scale;
    drawWalls();
    drawTemplates();
    drawFogToScreen();
    repositionAll();
  }
  zoomInBtn.addEventListener('click', () => setScale(scale * 1.2));
  zoomOutBtn.addEventListener('click', () => setScale(scale / 1.2));
  wrap.addEventListener('wheel', e => {
    e.preventDefault();
    setScale(scale * (e.deltaY < 0 ? 1.15 : 0.87), e.offsetX, e.offsetY);
  }, { passive: false });

  /* Map upload */
  mapUpload.addEventListener('change', e => {
    const file = e.target.files?.[0];
    if (!file) return;
    const r = new FileReader();
    r.onload = ev => {
      mapEl.onload = () => {
        resetFogWorld();
        fitCanvases();
      };
      mapEl.src = ev.target.result;
    };
    r.onerror = () => alert("Failed to load image");
    r.readAsDataURL(file);
  });

  /* Tools */
  function setTool(t) {
    currentTool = t;
    toolButtons.forEach(b => b.classList.toggle('toggled', b.dataset.tool === t));
    updateFogInteractivity();
    mapEl.style.cursor = t==='pan' ? 'grab' : 'crosshair';
  }
  toolButtons.forEach(b => b.addEventListener('click', () => setTool(b.dataset.tool)));
  setTool('pan');

  function updateFogInteractivity() {
    const on = fogModeSel.value !== 'none';
    fog.style.pointerEvents = on ? 'auto' : 'none';
    document.body.classList.toggle('fog-edit', on);
    fog.classList.toggle('fog-active', on);
    if (!on && action && action.type==='fog') action=null;
  }
  fogModeSel.addEventListener('change', updateFogInteractivity);
  updateFogInteractivity();

  /* FOG */
  function resetFogWorld(){
    const w = wrap.clientWidth  || 1;
    const h = wrap.clientHeight || 1;
    fogTex.width  = w;
    fogTex.height = h;
    fogx = fogTex.getContext('2d');
    fogx.clearRect(0,0,w,h);
    fogUndoStack = []; fogRedoStack = [];
    pushFogState();
  }
  function pushFogState() {
    try {
          } else {
      alert('Nothing selected with an assigned submap.');
    }

  /* TEMPLATES (ruler/circle/cone) */
  function drawTemplates(){
    const dpr = window.devicePixelRatio || 1;
    const w = tpl.width / dpr, h = tpl.height / dpr;
    tctx.clearRect(0,0,w,h);
    tctx.lineWidth = Math.max(2, 2*scale);
    tctx.strokeStyle = '#80d8ff';
    tctx.fillStyle = 'rgba(128,216,255,.15)';

    const render = (t)=>{
      if (t.type==='ruler'){
        const a=worldToScreen(t.start.x,t.start.y), b=worldToScreen(t.end.x,t.end.y);
        tctx.beginPath(); tctx.moveTo(a.x,a.y); tctx.lineTo(b.x,b.y); tctx.stroke();
      } else if (t.type==='circle'){
        const c=worldToScreen(t.start.x,t.start.y);
        tctx.beginPath(); tctx.arc(c.x,c.y, t.r*scale, 0, Math.PI*2); tctx.fill(); tctx.stroke();
      } else if (t.type==='cone'){
        const c=worldToScreen(t.start.x,t.start.y);
        tctx.beginPath();
        tctx.moveTo(c.x,c.y);
        tctx.arc(c.x,c.y, t.r*scale, t.a0, t.a1);
        tctx.closePath(); tctx.fill(); tctx.stroke();
      }
    };
    templates.forEach(render);
    if (action && action.type==='draw' && action.draft) render(action.draft);
  }
  clearTplBtn.addEventListener('click', ()=>{ templates=[]; drawTemplates(); });

  /* WALLS */
  function drawWalls(){
    const dpr = window.devicePixelRatio || 1;
    const w = wallsLayer.width / dpr, h = wallsLayer.height / dpr;
    wctx.clearRect(0,0,w,h);
    wctx.lineWidth = Math.max(2, 2*scale);
    walls.forEach(seg=>{
      const A=worldToScreen(seg.a.x,seg.a.y), B=worldToScreen(seg.b.x,seg.b.y);
      wctx.strokeStyle = seg.type==='door' ? (seg.open?'#4caf50':'#ffc107') :
                         seg.type==='window' ? '#80d8ff' : '#ff7961';
      wctx.beginPath(); wctx.moveTo(A.x,A.y); wctx.lineTo(B.x,B.y); wctx.stroke();
    });
    if (drawingWall?.points?.length){
      wctx.strokeStyle='#ffd54f'; wctx.setLineDash([6,6]);
      drawingWall.points.forEach((p,i)=>{
        const s=worldToScreen(p.x,p.y);
        if(i===0) wctx.beginPath(), wctx.moveTo(s.x,s.y); else wctx.lineTo(s.x,s.y);
      });
      wctx.stroke(); wctx.setLineDash([]);
    }
  }
  function ccw(A,B,C){ return (C.y-A.y)*(B.x-A.x) > (B.y-A.y)*(C.x-A.x); }
  function segIntersect(a,b,c,d){ return ccw(a,c,d) !== ccw(b,c,d) && ccw(a,b,c) !== ccw(a,b,d); }
  function moveBlocked(from, to){
    for (const w of walls){
      if (w.type==='door' && w.open) continue;
      if (segIntersect(from, to, w.a, w.b)) return true;
    }
    return false;
  }

  /* TOKENS */
  function addToken({name,color,size,img,x,y,sheet}){
    const el = document.createElement('div');
    el.className = 'token';
    el.style.width = el.style.height = (size||42)+'px';
    el.style.background = color || '#f44';
    el.innerHTML = '<span>'+ (name||'T') +'</span>';
    if (img){ el.classList.add('has-img'); el.style.backgroundImage = `url(${img})`; }
    wrap.appendChild(el);
    const t = {el, name, color, size: size||42, x: x??100, y: y??100, img, sheet: sheet||null};
    tokens.push(t);
    const s = worldToScreen(t.x,t.y);
    el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    el.style.transformOrigin = 'top left';
    return t;
  }
  createTokenBtn.addEventListener('click', ()=>{
    const name = tfName.value.trim()||'T';
    const color= tfColor.value;
    const size = clamp(parseInt(tfSize.value||42,10), 24, 120);
    if (tfPhoto.files?.[0]){
      const r = new FileReader();
      r.onload = ev => addToken({name,color,size,img:ev.target.result});
      r.readAsDataURL(tfPhoto.files[0]);
    } else {
      addToken({name,color,size});
    }
  });

  /* PORTALS */
  function makePortal(x,y,w,h,targetName){
    const el = document.createElement('div');
    el.className = 'portal';
    el.style.width = Math.max(1,w) + 'px';
    el.style.height = Math.max(1,h) + 'px';
    wrap.appendChild(el);
    const p = {el, x, y, w:Math.max(1,w), h:Math.max(1,h), targetName: targetName||null};
    portals.push(p);
    const s = worldToScreen(x,y);
    el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    el.style.transformOrigin = 'top left';
    el.addEventListener('mousedown', (e)=>{
      if (currentTool!=='select') return;
      selectedPortal = p; selectedToken=null;
      e.preventDefault();
    });
    el.addEventListener('dblclick', ()=>{
      if (p.targetName){
        const s = submaps.find(x=>x.name===p.targetName);
        if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
      } else {
        promptAssignPortal(p);
      }
    });
    return p;
  }
  function promptAssignPortal(p){
    if (!submaps.length){ alert('No submaps in library. Add one on the right.'); return; }
    const pick = prompt('Assign to submap (type name):
'+ submaps.map(s=>s.name).join('
'));
    if (!pick) return;
    const exists = submaps.find(s=>s.name===pick);
    if (!exists) { alert('Not found.'); return; }
    p.targetName = pick;
  }

  /* CONTEXT MENU */
  wrap.addEventListener('contextmenu', (e)=>{
    e.preventDefault();
    // detect if portal or token clicked
    selectedPortal = null; selectedToken=null;
    const el = e.target.closest('.portal,.token');
    if (el?.classList.contains('portal')){
      selectedPortal = portals.find(p=>p.el===el) || null;
    } else if (el?.classList.contains('token')){
      selectedToken  = tokens.find(t=>t.el===el) || null;
    }
    ctxMenu.style.display='block';
    ctxMenu.style.left = e.clientX+'px';
    ctxMenu.style.top  = e.clientY+'px';
  });
  window.addEventListener('click', (e)=>{
    if (!ctxMenu.contains(e.target)) ctxMenu.style.display='none';
  });

  ctxMenu.addEventListener('click', (e)=>{
    const act = e.target.getAttribute('data-act');
    if (!act) return;
    ctxMenu.style.display='none';
    if (act==='delete'){
      if (selectedPortal){
        selectedPortal.el.remove();
        portals = portals.filter(p=>p!==selectedPortal);
        selectedPortal=null;
      } else if (selectedToken){
        selectedToken.el.remove();
        tokens = tokens.filter(t=>t!==selectedToken);
        selectedToken=null;
      }
    } else if (act==='assign-submap'){
      const names = submaps.map(s=>s.name);
      if (!names.length) return alert('No submaps in library. Add one on the right.');
      const pick = prompt('Assign to submap (type name):\n'+names.join('\n'));
      if (!pick) return;
      const exists = submaps.find(s=>s.name===pick);
      if (!exists) return alert('Not found.');
      if (selectedPortal) selectedPortal.targetName = pick;
      if (selectedToken)  selectedToken.sheet = { submap: pick };
    } else if (act==='open-submap'){
      if (selectedPortal && selectedPortal.targetName){
        const s = submaps.find(x=>x.name===selectedPortal.targetName);
        if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
      } else if (selectedToken && selectedToken.sheet?.submap){
        const s = submaps.find(x=>x.name===selectedToken.sheet.submap);
        if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
      } else {
        function startDraw(e){
  const pt = pointerToWrap(e);
  const pos = screenToWorld(pt.x, pt.y);
  const sx = snap(pos.x), sy = snap(pos.y);
  if (currentTool==='ruler'){
    action = { type:'draw', draft:{type:'ruler', start:{x:sx,y:sy}, end:{x:sx,y:sy}} };
  } else if (currentTool==='circle'){
    action = { type:'draw', draft:{type:'circle', start:{x:sx,y:sy}, r:1} };
  } else if (currentTool==='cone'){
    action = { type:'draw', draft:{type:'cone', start:{x:sx,y:sy}, r:1, a0:0, a1:0} };
  } else if (currentTool==='wall'){
    if (!drawingWall) drawingWall = {points:[], type:'wall'};
    drawingWall.points.push({x:sx,y:sy});
    drawWalls();
  } else if (currentTool==='portal'){
    action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ 
      const g = document.createElement('div'); 
      g.className = 'portal'; 
      g.style.width = '1px'; 
      g.style.height = '1px'; 
      wrap.appendChild(g); 
      return g;
    })() };
    const s = worldToScreen(sx, sy);
    action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
  }
}
      if (!drawingWall) drawingWall = {points:[], type:'wall'};
      drawingWall.points.push({x:sx,y:sy});
      drawWalls();
    } else if (currentTool==='portal'){
      action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ const g=document.createElement('div'); g.className='portal'; g.style.width='1px'; g.style.height='1px'; wrap.appendChild(g); return g;})() };
      const s = worldToScreen(sx, sy);
      action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    }
  }

  /* SUBMAPS */
  const subOverlay = document.getElementById('submap-overlay');
  const subCanvas  = document.getElementById('submap-canvas');
  const subCtx     = subCanvas.getContext('2d');
  function openSubmap(imgSrc, title='Submap'){
    document.getElementById('submap-title').textContent = title;
    subOverlay.style.display = 'block';
    subOverlay.setAttribute('aria-hidden','false');

    const img = new Image();
    img.onload = ()=>{
      requestAnimationFrame(()=>{
        const dpr = window.devicePixelRatio || 1;
        const w = subCanvas.clientWidth || 1;
        const h = subCanvas.clientHeight || 1;
        subCanvas.width = Math.floor(w * dpr);
        subCanvas.height= Math.floor(h * dpr);
        subCtx.setTransform(dpr,0,0,dpr,0,0);

        const ratio = Math.max(w/img.width, h/img.height);
        const dw = img.width*ratio, dh = img.height*ratio;
        const dx = (w - dw)/2, dy = (h - dh)/2;
        subCtx.clearRect(0,0,w,h);
        subCtx.drawImage(img, dx, dy, dw, dh);
      });
    };
    img.src = imgSrc;
  }
  document.getElementById('close-submap').addEventListener('click', ()=>{
    subOverlay.style.display='none';
    subOverlay.setAttribute('aria-hidden','true');
  });
  subAddBtn.addEventListener('click', ()=>{
    const file = subFile.files?.[0];
    const name = (subName.value.trim()||'Submap');
    if (!file) return alert('Choose an image');
    const r = new FileReader();
    r.onload = ev=>{
      submaps.push({name, img: ev.target.result});
      localStorage.setItem('warvault-submaps', JSON.stringify(submaps));
      renderSubmaps();
    };
    r.readAsDataURL(file);
  });
  function renderSubmaps(){
    subList.innerHTML='';
    submaps.forEach((s,i)=>{
      const row = document.createElement('div');
      row.className='map-item';
      row.innerHTML = `
        <div class="thumb" style="background-image:url('${s.img}')"></div>
        <div style="flex:1">
          <div>${s.name}</div>
        </div>
        <button class="btn" data-i="${i}" data-act="open">Open</button>
        <button class="btn" data-i="${i}" data-act="del">Delete</button>
      `;
      row.querySelector('[data-act="open"]').onclick = ()=> openSubmap(s.img, s.name);
      row.querySelector('[data-act="del"]').onclick  = ()=>{
        submaps.splice(i,1);
        localStorage.setItem('warvault-submaps', JSON.stringify(submaps));
        renderSubmaps();
function startDraw(e){
  const pt = pointerToWrap(e);
  const pos = screenToWorld(pt.x, pt.y);
  const sx = snap(pos.x), sy = snap(pos.y);
  if (currentTool==='ruler'){
    action = { type:'draw', draft:{type:'ruler', start:{x:sx,y:sy}, end:{x:sx,y:sy}} };
  } else if (currentTool==='circle'){
    action = { type:'draw', draft:{type:'circle', start:{x:sx,y:sy}, r:1} };
  } else if (currentTool==='cone'){
    action = { type:'draw', draft:{type:'cone', start:{x:sx,y:sy}, r:1, a0:0, a1:0} };
  } else if (currentTool==='wall'){
    if (!drawingWall) drawingWall = {points:[], type:'wall'};
    drawingWall.points.push({x:sx,y:sy});
    drawWalls();
  } else if (currentTool==='portal'){
    action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ 
      const g = document.createElement('div'); 
      g.className = 'portal'; 
      g.style.width = '1px'; 
      g.style.height = '1px'; 
      wrap.appendChild(g); 
      return g;
    })() };
    const s = worldToScreen(sx, sy);
    action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
  }
}
      return;
    }
    sessions.slice().reverse().forEach((m, idxFromEnd)=>{
      const idx = sessions.length-1-idxFromEnd;
      const row = document.createElement('div');
      row.className='map-item';
      row.innerHTML = `
        <div class="thumb" style="background-image:url('${m.thumb||m.map?.src||""}')"></div>
        <div style="flex:1">
          <div>${m.name || 'Session'} — ${new Date(m.when).toLocaleString()}</div>
        </div>
        <button class="btn" data-act="load">Load</button>
        <button class="btn" data-act="remove">Delete</button>
      `;
      row.querySelector('[data-act="load"]').onclick = ()=> loadSession(m);
      row.querySelector('[data-act="remove"]').onclick = ()=>{
        sessions.splice(idx,1);
        localStorage.setItem('warvault-maps', JSON.stringify(sessions));
        renderSaved();
      };
      savedMapsDiv.appendChild(row);
    });
  }
  function collectSession(){
    return {
      when: Date.now(),
      name: 'WarVault Session',
      map: { src: mapEl.src },
      fog: fogTex.toDataURL('image/webp', 0.85),
      tokens: tokens.map(t=>({name:t.name,color:t.color,size:t.size,x:t.x,y:t.y,img:t.img||null,sheet:t.sheet||null})),
      portals: portals.map(p=>({x:p.x,y:p.y,w:p.w,h:p.h,targetName:p.targetName||null})),
      walls: walls.map(w=>({a:w.a,b:w.b,type:w.type,open:w.open})),
      templates,
      settings: { cell, scale, offset }
    };
  }
  function applySessionState(s){
    resetFogWorld();
    // fog
    if (s.fog){
      const img=new Image(); img.onload=()=>{
        fogx.clearRect(0,0,fogTex.width,fogTex.height);
        fogx.drawImage(img,0,0, fogTex.width, fogTex.height);
        drawFogToScreen();
      }; img.src=s.fog;
    } else { drawFogToScreen(); }

    // tokens
    tokens.forEach(t=>t.el.remove()); tokens=[];
    (s.tokens||[]).forEach(t=> addToken(t));

    // portals
    portals.forEach(p=>p.el.remove()); portals=[];
    (s.portals||[]).forEach(p=> makePortal(p.x,p.y,p.w,p.h,p.targetName||null));

    // walls
    walls = (s.walls||[]).map(w=>({a:w.a,b:w.b,type:w.type||'wall',open:!!w.open}));
    drawWalls();

    // templates
    templates = s.templates || [];
    drawTemplates();

    // settings
    if (s.settings){
      offset = s.settings.offset || {x:0,y:0};
      scale  = s.settings.scale  || 1;
    }
    repositionAll();
    drawFX();
    fitCanvases();
    setTool('pan');
  }
  function loadSession(s){
    // Reset transient state before swapping
    action=null; drawingWall=null; selectedToken=null; selectedPortal=null;
    document.body.classList.remove('fog-edit');
    fog.classList.remove('fog-active');

    const targetSrc = s?.map?.src;
    if (!targetSrc){ alert('This save has no map reference.'); return; }

    const same = mapEl.src === targetSrc;
    // If the same image is already loaded, browsers won't fire onload.
    if (same && mapEl.complete && mapEl.naturalWidth>0){
      applySessionState(s);
      return;
    }

    mapEl.onload = ()=>{ applySessionState(s); };

    // Force reload if same src to ensure onload fires on some browsers
    if (same){
      mapEl.src = '';
      setTimeout(()=>{ mapEl.src = targetSrc; }, 0);
    } else {
      mapEl.src = targetSrc;
    }
  }

  saveMapBtn.addEventListener('click', ()=>{
    const snap = collectSession();
    snap.thumb = mapEl.src;
    sessions.push(snap);
    try{
      localStorage.setItem('warvault-maps', JSON.stringify(sessions));
      renderSaved();
      alert('Session saved locally.');
    } catch(e){
      console.error(e);
      alert('Save failed (storage full?). Delete older sessions and try again.');
      sessions.pop();
    }
  });
  renderSaved();

  /* Initiative */
  function renderInit(){
    initList.innerHTML='';
    initiative.forEach((it,idx)=>{
      const row = document.createElement('div');
      row.style.display='flex';
      row.style.gap='.5rem';
      row.style.alignItems='center';
      row.innerHTML = `
        <div style="width:28px;text-align:right;color:${idx===initIdx?'#0f0':'#aaa'}">${idx===initIdx?'▶':''}</div>
        <div style="flex:1">${it.name}</div>
        <div style="width:40px;text-align:right">${it.roll}</div>
        <button class="btn" data-i="${idx}">✕</button>
      `;
      row.querySelector('button').onclick = ()=>{
        initiative.splice(idx,1);
        if (initIdx >= initiative.length) initIdx = initiative.length-1;
        renderInit();
      };
      initList.appendChild(row);
    });
  }
  initAdd.onclick = ()=>{
    const name = initName.value.trim();
    const roll = parseInt(initRoll.value,10);
    if (!name || !Number.isFinite(roll)) return;
    initiative.push({name, roll});
    initiative.sort((a,b)=>b.roll-a.roll);
    initName.value=''; initRoll.value='';
    if (initIdx===-1) initIdx=0;
    renderInit();
  };
  initNext.onclick = ()=>{
    if (!initiative.length) return;
    initIdx = (initIdx+1)%initiative.length;
    renderInit();
  };
  initReset.onclick = ()=>{ initiative=[]; initIdx=-1; renderInit(); };

  /* Omniverse bridge (optional) */
  function logOv(msg) {
    ovConsole.innerHTML += `<div>${new Date().toLocaleTimeString()} — ${msg}</div>`;
    ovConsole.scrollTop = ovConsole.scrollHeight;
  }
  function ensureWS(){
    if (ws && (ws.readyState===WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING)) return;
    ws = new WebSocket('ws://localhost:8080/omniverse');
    ws.onopen = ()=> logOv("Bridge connected");
    ws.onclose = ()=> logOv("Bridge disconnected");
    ws.onerror = ()=> logOv("Bridge error");
    ws.onmessage = (e)=>{
      try {
        const msg = JSON.parse(e.data);
        if (msg.type === 'map') {
          mapEl.onload = ()=>{ resetFogWorld(); fitCanvases(); };
          mapEl.src = msg.image;
          logOv("Map loaded.");
        } else if (msg.type === 'list') {
          buildLibrary(msg.items||[]);
        } else if (msg.type === 'error') {
          logOv("Error: " + msg.message); alert(msg.message);
        } else if (msg.type === 'info') {
          logOv(msg.message||'Info');
        }
      } catch { /* ignore */ }
    };
  }
  ovHelpBtn.onclick = () => { ovHelp.style.display = ovHelp.style.display === 'block' ? 'none' : 'block'; };
  document.addEventListener('click', (e) => { if (!ovHelp.contains(e.target) && e.target !== ovHelpBtn) ovHelp.style.display = 'none'; });
  ovConnect.onclick  = ()=>{ if (!ovUrl.value || !ovUsd.value) return alert("Fill URL and USD path"); ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({action:'connect', url:ovUrl.value, usd:ovUsd.value })); logOv("Requested connection"); } else logOv("Connecting…"); };
  ovGenerate.onclick = ()=>{ ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({action:'generate', res:ovRes.value, format:ovFormat.value})); logOv("Generating map…"); } else logOv("Bridge not connected"); };
  ovRefresh.onclick  = ()=>{ ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({action:'last'})); logOv("Fetching last render…"); } };
  ovOpenLibrary.onclick = ()=>{ openRenders(); ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({action:'list'})); logOv("Listing renders…"); } };

  /* Previous renders modal */
  function openRenders(){ rendersModal.style.display='flex'; }
  function closeRenders(){ rendersModal.style.display='none'; }
  openRendersBtn.onclick = ()=>{ openRenders(); ensureWS(); if (ws?.readyState===WebSocket.OPEN) ws.send(JSON.stringify({ action:'list' })); };
  rendersClose.onclick   = closeRenders;
  rendersModal.addEventListener('click', (e)=>{ if (e.target===rendersModal) closeRenders(); });

  function buildLibrary(items){
    rlGrid.innerHTML = '';
    if (!items.length){
      rlGrid.innerHTML = '<div class="sub">No renders found. Click “Generate Map” first.</div>';
      return;
    }
    items.sort((a,b)=>(b.mtime||'').localeCompare(a.mtime||''));
    items.forEach(it=>{
      const card = document.createElement('div');
      card.className = 'rl-card';
      const thumb = it.thumb || '';
      const when  = it.mtime ? new Date(it.mtime).toLocaleString() : '';
      card.innerHTML = `
        <div class="rl-shot" style="background-image:url('${thumb}')"></div>
        <div class="rl-meta">
          <div style="color:#fff">${it.name || 'Render'}</div>
          <div style="color:#c9b27a">${when}</div>
        </div>
        <div class="rl-actions">
          <button class="btn" data-act="load">Load</button>
          <button class="btn" data-act="copy">Copy Name</button>
        </div>`;
      card.querySelector('[data-act="load"]').onclick = ()=>{ ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({ action:'get', name: it.name })); logOv('Loading ' + it.name); closeRenders(); } };
      card.querySelector('[data-act="copy"]').onclick = ()=>{ navigator.clipboard.writeText(it.name).then(()=>logOv('Name copied.')); };
      rlGrid.appendChild(card);
    });
  }

  /* ===== Unified Pointer Interactions to prevent "crazy" buttons ===== */
  function startPan(e){
    action = { type:'pan', startX:e.clientX, startY:e.clientY, ox:offset.x, oy:offset.y };
    wrap.style.cursor = 'grabbing';
  }
  function updatePan(e){
    const dx = e.clientX - action.startX;
    const dy = e.clientY - action.startY;
    offset.x = action.ox + dx;
    offset.y = action.oy + dy;
    drawWalls();
    drawTemplates();
    drawFogToScreen();
    repositionAll();
  }
  function endPan(){ wrap.style.cursor = currentTool==='pan' ? 'grab' : 'crosshair'; }

  function startDraw(e){
    const pt = pointerToWrap(e);
    const pos = screenToWorld(pt.x, pt.y);
    const sx = snap(pos.x), sy = snap(pos.y);
    if (currentTool==='ruler'){
      action = { type:'draw', draft:{type:'ruler', start:{x:sx,y:sy}, end:{x:sx,y:sy}} };
    } else if (currentTool==='circle'){
      action = { type:'draw', draft:{type:'circle', start:{x:sx,y:sy}, r:1} };
    } else if (currentTool==='cone'){
      action = { type:'draw', draft:{type:'cone', start:{x:sx,y:sy}, r:1, a0:0, a1:0} };
    } else if (currentTool==='wall'){
      if (!drawingWall) drawingWall = {points:[], type:'wall'};
      drawingWall.points.push({x:sx,y:sy});
      drawWalls();
    } else if (currentTool==='portal'){
      action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ const g=document.createElement('div'); g.className='portal'; g.style.width='1px'; g.style.height='1px'; wrap.appendChild(g); return g;})() };
      const s = worldToScreen(sx, sy);
      action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    }
  }, end:{x:sx,y:sy}} };
    } else if (currentTool==='circle'){
      action = { type:'draw', draft:{type:'circle', start:{x:sx,y:sy}, r:1} };
    } else if (currentTool==='cone'){
      action = { type:'draw', draft:{type:'cone', start:{x:sx,y:sy}, r:1, a0:0, a1:0} };
    } else if (currentTool==='wall'){
      if (!drawingWall) drawingWall = {points:[], type:'wall'};
      drawingWall.points.push({x:sx,y:sy});
      drawWalls();
    } else if (currentTool==='portal'){
      action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ const g=document.createElement('div'); g.className='portal'; g.style.width='1px'; g.style.height='1px'; wrap.appendChild(g); return g;})() };
      const s = worldToScreen(sx, sy);
      action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    }
  }
  function updateDraw(e){
    if (!action) return;
    const pt = pointerToWrap(e);
    const pos = screenToWorld(pt.x, pt.y);
    const sx = snap(pos.x), sy = snap(pos.y);
    if (action.type==='draw' && action.draft){
      if (action.draft.type==='ruler'){
        action.draft.end = {x:sx, y:sy};
      } else if (action.draft.type==='circle'){
        const dx = sx - action.draft.start.x, dy = sy - action.draft.start.y;
        action.draft.r = Math.max(1, Math.hypot(dx,dy));
      } else if (action.draft.type==='cone'){
        const dx = sx - action.draft.start.x, dy = sy - action.draft.start.y;
        const r = Math.max(1, Math.hypot(dx,dy));
        const ang = Math.atan2(dy,dx);
        const spread = Math.PI/3;
        action.draft.r = r; action.draft.a0 = ang - spread/2; action.draft.a1 = ang + spread/2;
      }
      drawTemplates();
    } else if (action.type==='portal' && action.ghost){
      const w = sx - action.start.x; const h = sy - action.start.y;
      const gx = worldToScreen(Math.min(action.start.x, action.start.x + w), Math.min(action.start.y, action.start.y + h));
      action.ghost.style.width  = Math.abs(w) + 'px';
      action.ghost.style.height = Math.abs(h) + 'px';
      action.ghost.style.transform = `translate(${gx.x}px, ${gx.y}px) scale(${scale})`;
    }
  };
      } else if (action.draft.type==='circle'){
        const dx = sx - action.draft.start.x, dy = sy - action.draft.start.y;
        action.draft.r = Math.max(1, Math.hypot(dx,dy));
      } else if (action.draft.type==='cone'){
        const dx = sx - action.draft.start.x, dy = sy - action.draft.start.y;
        const r = Math.max(1, Math.hypot(dx,dy));
        const ang = Math.atan2(dy,dx);
        const spread = Math.PI/3;
        action.draft.r = r; action.draft.a0 = ang - spread/2; action.draft.a1 = ang + spread/2;
      }
      drawTemplates();
    } else if (action.type==='portal' && action.ghost){
      const w = sx - action.start.x; const h = sy - action.start.y;
      const gx = worldToScreen(Math.min(action.start.x, action.start.x + w), Math.min(action.start.y, action.start.y + h));
      action.ghost.style.width  = Math.abs(w) + 'px';
      action.ghost.style.height = Math.abs(h) + 'px';
      action.ghost.style.transform = `translate(${gx.x}px, ${gx.y}px) scale(${scale})`;
    }
  }
  function endDraw(){
    if (!action) return;
    if (action.type==='draw' && action.draft){
      templates.push(action.draft);
      action=null; drawTemplates();
    } else if (action.type==='portal' && action.ghost){
      const rect = action.ghost.getBoundingClientRect();
      action.ghost.remove();
      const wrapRect = wrap.getBoundingClientRect();
      const a = action.start;
      const b = screenToWorld(rect.right - wrapRect.left, rect.bottom - wrapRect.top);
      const x = Math.min(a.x, b.x), y = Math.min(a.y, b.y);
      const w = Math.max(1, Math.abs(b.x - a.x));
      const h = Math.max(1, Math.abs(b.y - a.y));
      const newP = makePortal(x,y,w,h,null);
      promptAssignPortal(newP);
      action=null;
    }
  } else if (action.type==='portal' && action.ghost){
      const rect = action.ghost.getBoundingClientRect();
      action.ghost.remove();
      const wrapRect = wrap.getBoundingClientRect();
      const a = action.start;
      const b = screenToWorld(rect.right - wrapRect.left, rect.bottom - wrapRect.top);
      const x = Math.min(a.x, b.x), y = Math.min(a.y, b.y);
      const w = Math.max(1, Math.abs(b.x - a.x));
      const h = Math.max(1, Math.abs(b.y - a.y));
      makePortal(x,y,w,h,null);
      action=null;
    }
  }

  function startTokenDrag(token, e){
    action = { type:'token', token, sx:e.clientX, sy:e.clientY, startX:token.x, startY:token.y };
  }
  function updateTokenDrag(e){
    const tok = action.token;
    const dx = (e.clientX - action.sx)/scale;
    const dy = (e.clientY - action.sy)/scale;
    const prop = { x: snap(action.startX+dx), y: snap(action.startY+dy) };
    if (moveBlocked({x:action.startX,y:action.startY}, prop)) return;
    tok.x = prop.x; tok.y = prop.y;
    const s = worldToScreen(tok.x,tok.y);
    tok.el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
  }

  // Unified pointer handlers for the map container
  wrap.addEventListener('pointerdown', (e)=>{
    // Ignore right/middle in main flow; contextmenu handles right
    if (e.button !== 0) return;
    const targetToken = e.target.closest('.token');
    if (currentTool==='select' && targetToken){
      selectedToken = tokens.find(t=>t.el===targetToken) || null;
      if (selectedToken){ startTokenDrag(selectedToken, e); wrap.setPointerCapture?.(e.pointerId); e.preventDefault(); }
      return;
    }
    if (currentTool==='pan') { startPan(e); wrap.setPointerCapture?.(e.pointerId); e.preventDefault(); return; }
    startDraw(e); wrap.setPointerCapture?.(e.pointerId); e.preventDefault();
  });

  wrap.addEventListener('pointermove', (e)=>{
    if (!action) return;
    if (action.type==='pan') updatePan(e);
    else if (action.type==='draw' || action.type==='portal') updateDraw(e);
    else if (action.type==='token') updateTokenDrag(e);
  });

  wrap.addEventListener('pointerup', ()=>{
    if (!action) return;
    if (action.type==='pan') { endPan(); action=null; return; }
    if (action.type==='draw' || action.type==='portal') { endDraw(); return; }
    if (action.type==='token') { action=null; return; }
  });

  // Finish wall drawing via keyboard (unchanged)
  document.addEventListener('keydown', (e)=>{
    if (currentTool!=='wall') return;
    if (e.key==='Escape'){ drawingWall=null; drawWalls(); }
    if (e.key==='Enter' && drawingWall?.points?.length>1){
      for(let i=1;i<drawingWall.points.length;i++){
        walls.push({ a:drawingWall.points[i-1], b:drawingWall.points[i], type:'wall', open:false });
      }
      drawingWall=null; drawWalls();
    }
  });

  /* Init */
  resetFogWorld();
  fitCanvases();
  setTool('pan');
};
</script>
</body>
</html>
