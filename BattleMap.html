<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D&D Character Sheet ‚Äî DDB‚Äëstyle</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&family=Cinzel:wght@700;800;900&display=swap" rel="stylesheet">
<style>
  :root{
    --ink:#e9e9ee;--bg:#0f1015;--panel:#14151c;--muted:#9aa2b1;--red:#ef4444;--gold:#f4cc7a;--line:#252838;--pill:#1c1f2b;--accent:#8ecae6;--green:#22c55e;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1800px 800px at 70% -10%, #1a1c26 0%, #0f1015 55%);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,sans-serif}
  .sheet{max-width:1180px;margin:18px auto;padding:12px 16px}
  .topbar{display:flex;align-items:center;gap:12px}
  .avatar{width:72px;height:72px;border-radius:12px;background:#222 url('https://images.unsplash.com/photo-1558981806-ec527fa84c39?q=80&w=400&auto=format&fit=crop') center/cover no-repeat;border:2px solid #303448}
  .header{display:grid;grid-template-columns:1fr auto auto auto;gap:12px;align-items:center;width:100%}
  .name{font-family:Cinzel,serif;font-weight:900;letter-spacing:.02em;font-size:28px}
  .badge{padding:6px 10px;background:var(--pill);border:1px solid var(--line);border-radius:999px;color:var(--muted);font-weight:600}
  .btn{cursor:pointer;border-radius:10px;border:1px solid var(--line);background:linear-gradient(#1a1d27,#171923);color:var(--ink);padding:8px 10px;font-weight:600}
  .btn:hover{border-color:#3a3f57}
  .grid{display:grid;grid-template-columns:300px 1fr 330px;gap:14px;margin-top:12px}
  @media (max-width:1100px){.grid{grid-template-columns:1fr}}
  .card{background:linear-gradient(180deg,#161823,#131520);border:1px solid var(--line);border-radius:14px;box-shadow:0 12px 30px rgba(0,0,0,.35)}
  .card h3{margin:0 0 6px;font-family:Cinzel,serif;letter-spacing:.04em;color:var(--gold);font-size:16px}
  .card .pad{padding:10px 12px}
  .statgrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .ability{position:relative;background:#12131b;border:1px solid var(--line);border-radius:12px;padding:10px;text-align:center}
  .ability .abbr{font-weight:800;color:#d7def5}
  .ability .score{font-size:28px;font-weight:800;margin:6px 0}
  .ability .mod{font-weight:800;background:#10121c;border:1px solid #2a2f45;border-radius:8px;padding:6px 0}
  .pillrow{display:flex;gap:8px;flex-wrap:wrap}
  .pill{background:var(--pill);border:1px solid var(--line);border-radius:999px;padding:6px 8px;font-weight:600;color:var(--muted)}

  .box{background:#12131b;border:1px dashed var(--line);border-radius:12px;padding:8px}
  .kv{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .kv div:nth-child(2){font-weight:800}

  /* right column blocks */
  .hpac{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .hp{background:#10121c;border:1px solid var(--line);border-radius:12px;padding:10px;text-align:center}
  .hp .ttl{font-weight:700;color:#cbd5e1}
  .hp .val{font-size:24px;font-weight:900}
  .hp.good{border-color:#204a33;box-shadow:inset 0 0 0 1px rgba(34,197,94,.35)}
  .hp.warn{border-color:#4a3a20;box-shadow:inset 0 0 0 1px rgba(244,204,122,.35)}

  /* Tabs */
  .tabs{margin-top:12px}
  .tabbar{display:flex;gap:10px;flex-wrap:wrap}
  .tabbar .tab{border:none;background:transparent;color:#cbd5e1;padding:8px 8px 10px;font-weight:800;letter-spacing:.02em;border-bottom:2px solid transparent;cursor:pointer}
  .tabbar .tab.active{color:var(--ink);border-bottom-color:var(--gold)}
  .tabpanel{display:none}
  .tabpanel.active{display:block}

  .subtabs{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 8px}
  .subtabs .sub{background:#171927;border:1px solid var(--line);border-radius:999px;padding:6px 10px;color:#cbd5e1;font-weight:700;cursor:pointer}
  .subtabs .sub.active{background:#20243a;border-color:#3b4161}

  .list{display:grid;gap:8px}
  .row{display:grid;grid-template-columns:1.2fr .6fr .6fr .6fr 1fr;gap:8px;align-items:center;background:#12131b;border:1px solid var(--line);border-radius:10px;padding:8px}
  .row .name{font-weight:700}
  .row small{color:#9aa2b1}

  .search{display:flex;gap:8px;margin:8px 0}
  .search input{flex:1;background:#12131b;border:1px solid var(--line);border-radius:10px;padding:8px;color:var(--ink)}
  .tag{display:inline-flex;align-items:center;gap:6px;background:#12131b;border:1px solid var(--line);border-radius:999px;padding:4px 8px;color:#b7c0d7;font-weight:700}

  .muted{color:var(--muted)}
  .num{font-feature-settings:"tnum" 1, "ss01" 1}
  .right{justify-self:end}
</style>
</head>
<body>
  <div class="sheet">
    <!-- header -->
    <div class="card pad">
      <div class="topbar">
        <div class="avatar" aria-hidden="true"></div>
        <div class="header">
          <div class="name" id="charName">Hjulkyl Foamtankard</div>
          <div class="badge" id="metaRace">Hill Dwarf ‚Ä¢ Male</div>
          <div class="badge" id="metaClass">Cleric 1</div>
          <div class="badge" id="campaign">Campaigny McCampaignface</div>
        </div>
      </div>
    </div>

    <!-- body grid -->
    <div class="grid">
      <!-- left: abilities & saving throws / skills -->
      <div class="card pad">
        <h3>Abilities</h3>
        <div class="statgrid" id="abilityGrid"></div>

        <div style="margin-top:10px" class="pillrow">
          <span class="pill">Poison Resistance</span>
          <span class="pill">Darkvision 60 ft.</span>
        </div>

        <div style="margin-top:12px">
          <h3>Saving Throws</h3>
          <div class="box" id="savesBox"></div>
        </div>

        <div style="margin-top:12px">
          <h3>Skills</h3>
          <div class="box" id="skillsBox"></div>
        </div>
      </div>

      <!-- middle: tabs -->
      <div class="card pad">
        <div class="tabs">
          <div class="tabbar" role="tablist">
            <button class="tab active" data-tab="actions" role="tab">ACTIONS</button>
            <button class="tab" data-tab="spells" role="tab">SPELLS</button>
            <button class="tab" data-tab="equipment" role="tab">EQUIPMENT</button>
            <button class="tab" data-tab="features" role="tab">FEATURES & TRAITS</button>
            <button class="tab" data-tab="description" role="tab">DESCRIPTION</button>
            <button class="tab" data-tab="notes" role="tab">NOTES</button>
            <button class="tab" data-tab="extras" role="tab">EXTRAS</button>
          </div>

          <!-- ACTIONS -->
          <section class="tabpanel active" id="tab-actions" role="tabpanel">
            <div class="subtabs" data-subgroup="actions">
              <button class="sub active" data-sub="atk">Attacks</button>
              <button class="sub" data-sub="class">Class Actions</button>
              <button class="sub" data-sub="other">Other</button>
            </div>
            <div class="search"><input placeholder="Search actions‚Ä¶"/></div>
            <div class="list" id="actionsList"></div>
          </section>

          <!-- SPELLS -->
          <section class="tabpanel" id="tab-spells" role="tabpanel">
            <div class="kv"><div>Spellcasting Ability</div><div id="spellAbility" class="right">WIS +2</div></div>
            <div class="kv"><div>Spell Save DC</div><div id="spellDC" class="right">12</div></div>
            <div class="kv"><div>Spell Attack Bonus</div><div id="spellAtk" class="right">+4</div></div>
            <div class="subtabs" data-subgroup="spells">
              <button class="sub active" data-sub="cantrips">Cantrips</button>
              <button class="sub" data-sub="lvl1">1st</button>
              <button class="sub" data-sub="lvl2">2nd</button>
              <button class="sub" data-sub="prep">Prepared</button>
            </div>
            <div class="search"><input placeholder="Search spells‚Ä¶"/></div>
            <div class="list" id="spellsList"></div>
          </section>

          <!-- EQUIPMENT -->
          <section class="tabpanel" id="tab-equipment" role="tabpanel">
            <div class="subtabs" data-subgroup="equip">
              <button class="sub active" data-sub="inv">Inventory</button>
              <button class="sub" data-sub="coins">Coins</button>
              <button class="sub" data-sub="attun">Attunements</button>
            </div>
            <div class="list" id="equipList"></div>
          </section>

          <!-- FEATURES & TRAITS -->
          <section class="tabpanel" id="tab-features" role="tabpanel">
            <div class="subtabs" data-subgroup="feat">
              <button class="sub active" data-sub="race">Racial</button>
              <button class="sub" data-sub="class">Class</button>
              <button class="sub" data-sub="other">Other</button>
            </div>
            <div class="list" id="featList"></div>
          </section>

          <!-- DESCRIPTION -->
          <section class="tabpanel" id="tab-description" role="tabpanel">
            <div class="subtabs" data-subgroup="desc">
              <button class="sub active" data-sub="bio">Bio</button>
              <button class="sub" data-sub="appearance">Appearance</button>
              <button class="sub" data-sub="backstory">Backstory</button>
            </div>
            <div class="list" id="descList"></div>
          </section>

          <!-- NOTES -->
          <section class="tabpanel" id="tab-notes" role="tabpanel">
            <div class="subtabs" data-subgroup="notes">
              <button class="sub active" data-sub="session">Session</button>
              <button class="sub" data-sub="dm">DM</button>
            </div>
            <div class="list" id="notesList"></div>
          </section>

          <!-- EXTRAS -->
          <section class="tabpanel" id="tab-extras" role="tabpanel">
            <div class="subtabs" data-subgroup="extras">
              <button class="sub active" data-sub="pets">Companions</button>
              <button class="sub" data-sub="custom">Custom</button>
            </div>
            <div class="list" id="extrasList"></div>
          </section>
        </div>
      </div>

      <!-- right: HP/AC and conditions -->
      <div class="card pad">
        <h3>Defenses</h3>
        <div class="hpac">
          <div class="hp good">
            <div class="ttl">ARMOR CLASS</div>
            <div class="val num" id="acVal">18</div>
          </div>
          <div class="hp good">
            <div class="ttl">HIT POINTS</div>
            <div class="val num"><span id="hpCur">12</span> / <span id="hpMax">12</span></div>
          </div>
          <div class="hp">
            <div class="ttl">TEMP HP</div>
            <div class="val num" id="hpTemp">0</div>
          </div>
        </div>
        <div style="margin-top:10px" class="pillrow">
          <span class="tag">Poisoned (resist)</span>
          <span class="tag">Proficiency +2</span>
          <span class="tag">Speed 25 ft</span>
          <span class="tag">Initiative -1</span>
        </div>
      </div>
    </div>
  </div>

<script>
// --- minimal data model (demo values) ---
const state = {
  abilities: { STR:12, DEX:8, CON:17, INT:10, WIS:15, CHA:13 },
  proficientSaves: ['WIS','CHA'],
  profBonus: 2,
  skills: {
    Acrobatics:'DEX', AnimalHandling:'WIS', Arcana:'INT', Athletics:'STR', Deception:'CHA',
    History:'INT', Insight:'WIS', Intimidation:'CHA', Investigation:'INT', Medicine:'WIS',
    Nature:'INT', Perception:'WIS', Performance:'CHA', Persuasion:'CHA', Religion:'INT',
    SleightOfHand:'DEX', Stealth:'DEX', Survival:'WIS'
  },
  proficientSkills: ['Insight','Medicine','History'],
  actions:{
    atk:[{name:'Warhammer',info:'Melee ‚Ä¢ 1d8 bludgeoning', bonus:'+4', damage:'1d8+2'}, {name:'Handaxe',info:'Melee ‚Ä¢ 1d6 slashing', bonus:'+4', damage:'1d6+2'}],
    class:[{name:'Channel Divinity',info:'1/rest ‚Ä¢ Present at later levels', bonus:'‚Äî', damage:'‚Äî'}],
    other:[{name:'Shove',info:'Special', bonus:'‚Äî', damage:'‚Äî'}]
  },
  spells:{
    cantrips:[{name:'Guidance', time:'1A', range:'Touch', hit:'‚Äî', effect:'Buff'}, {name:'Sacred Flame', time:'1A', range:'60 ft.', hit:'DEX 12', effect:'1d8‚ú¶'}],
    lvl1:[{name:'Bless', time:'1A', range:'30 ft.', effect:'Buff'}, {name:'Cure Wounds', time:'1A', range:'Touch', effect:'1d8+2‚ô•'}],
    lvl2:[], prepared:['Bless','Cure Wounds','Guidance','Sacred Flame']
  },
  equipment:{ inv:[
    {name:'Chain Mail', qty:1, weight:'55 lb', notes:'AC 16'},
    {name:'Shield', qty:1, weight:'6 lb', notes:'+2 AC'},
    {name:'Warhammer', qty:1, weight:'2 lb'},
    {name:'Explorer\'s Pack', qty:1, weight:'-'}
  ], coins:{gp:15, sp:8, cp:27}, attun:[] },
  features:{ race:['Dwarven Resilience','Dwarven Toughness'], class:['Spellcasting (Cleric)','Divine Domain TBD'], other:[]},
  description:{ bio:['Lawful Good ‚Ä¢ 55 years'], appearance:['Stocky, auburn beard'], backstory:['Left the mountainhold to serve the forge-god.']},
  notes:{ session:['Met the brewer guild.','Found a silver token.'], dm:['Remember poison traps.'] },
  extras:{ pets:['Mule (Pakko)'], custom:[] }
};

// --- helpers ---
const mod = s => Math.floor((s-10)/2);
const sign = n => (n>=0?'+':'')+n;

// --- abilities UI ---
const abilityGrid = document.getElementById('abilityGrid');
Object.entries(state.abilities).forEach(([abbr,score])=>{
  const el = document.createElement('div');
  el.className='ability';
  el.innerHTML = `<div class="abbr">${abbr}</div>
                  <div class="score num">${score}</div>
                  <div class="mod">${sign(mod(score))}</div>`;
  abilityGrid.appendChild(el);
});

// saves
const savesBox = document.getElementById('savesBox');
const saves = Object.entries(state.abilities).map(([abbr,score])=>{
  const isProf = state.proficientSaves.includes(abbr);
  const total = mod(score) + (isProf?state.profBonus:0);
  return `<div class="kv">
    <div>${abbr} Save ${isProf?'<span class="muted">(prof)</span>':''}</div>
    <div class="num">${sign(total)}</div>
  </div>`;
}).join('');
savesBox.innerHTML = saves;

// skills
const skillsBox = document.getElementById('skillsBox');
const skillsRows = Object.entries(state.skills).map(([name,stat])=>{
  const isProf = state.proficientSkills.includes(name);
  const total = mod(state.abilities[stat]) + (isProf?state.profBonus:0);
  const label = name.replace(/([A-Z])/g,' $1').trim();
  return `<div class="kv"><div>${label} <span class="muted">(${stat})</span> ${isProf?'<span class="muted">(prof)</span>':''}</div><div class="num">${sign(total)}</div></div>`;
}).join('');
skillsBox.innerHTML = skillsRows;

// --- tabs & subtabs ---
const tabs = document.querySelectorAll('.tabbar .tab');
const panels = document.querySelectorAll('.tabpanel');
tabs.forEach(btn=>{
  btn.addEventListener('click',()=>{
    tabs.forEach(b=>b.classList.remove('active'));
    panels.forEach(p=>p.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('tab-'+btn.dataset.tab).classList.add('active');
  });
});

function wireSubtabs(group, cb){
  const wrap = document.querySelector(`.subtabs[data-subgroup="${group}"]`);
  if (!wrap) return;
  wrap.addEventListener('click', e=>{
    const t = e.target.closest('.sub'); if(!t) return;
    wrap.querySelectorAll('.sub').forEach(s=>s.classList.remove('active'));
    t.classList.add('active');
    cb(t.dataset.sub);
  });
}

// ACTIONS
const actionsList = document.getElementById('actionsList');
function renderActions(kind='atk'){
  const items = state.actions[kind]||[];
  actionsList.innerHTML = items.map(a=>`
    <div class="row">
      <div class="name">${a.name}<br><small>${a.info||''}</small></div>
      <div class="num">${a.bonus||''}</div>
      <div class="num">${a.damage||''}</div>
      <div class="muted">‚Äî</div>
      <button class="btn right">Roll</button>
    </div>`).join('') || '<div class="muted">No actions.</div>';
}
renderActions();
wireSubtabs('actions', renderActions);

// SPELLS
const spellsList = document.getElementById('spellsList');
function renderSpells(sub='cantrips'){
  let items=[];
  if(sub==='cantrips') items = state.spells.cantrips;
  else if(sub==='lvl1') items = state.spells.lvl1;
  else if(sub==='lvl2') items = state.spells.lvl2;
  else if(sub==='prep') items = (state.spells.prepared||[]).map(n=>({name:n, time:'‚Äî', range:'‚Äî', hit:'‚Äî', effect:'Prepared'}));
  spellsList.innerHTML = items.map(s=>`
    <div class="row">
      <div class="name">${s.name}</div>
      <div>${s.time||''}</div>
      <div>${s.range||''}</div>
      <div class="num">${s.hit||''}</div>
      <div>${s.effect||''}</div>
    </div>`).join('') || '<div class="muted">No spells.</div>';
}
renderSpells();
wireSubtabs('spells', renderSpells);

document.getElementById('spellAbility').textContent = 'WIS '+sign(mod(state.abilities.WIS));
document.getElementById('spellDC').textContent = (8 + state.profBonus + mod(state.abilities.WIS));
document.getElementById('spellAtk').textContent = sign(state.profBonus + mod(state.abilities.WIS));

// EQUIPMENT
const equipList = document.getElementById('equipList');
function renderEquip(sub='inv'){
  if (sub==='inv'){
    equipList.innerHTML = state.equipment.inv.map(i=>`
      <div class="row">
        <div class="name">${i.name}</div>
        <div>${i.qty||1}x</div>
        <div>${i.weight||'-'}</div>
        <div class="muted">‚Äî</div>
        <div>${i.notes||''}</div>
      </div>`).join('');
  } else if (sub==='coins'){
    const c = state.equipment.coins; equipList.innerHTML = `
      <div class="row"><div class="name">Copper</div><div>${c.cp||0}</div><div></div><div></div><div></div></div>
      <div class="row"><div class="name">Silver</div><div>${c.sp||0}</div><div></div><div></div><div></div></div>
      <div class="row"><div class="name">Gold</div><div>${c.gp||0}</div><div></div><div></div><div></div></div>`;
  } else if (sub==='attun'){
    equipList.innerHTML = state.equipment.attun.length? state.equipment.attun.map(n=>`<div class="row"><div class="name">${n}</div><div></div><div></div><div></div><div></div></div>`).join('') : '<div class="muted">No attuned items.</div>';
  }
}
renderEquip();
wireSubtabs('equip', renderEquip);

// FEATURES & TRAITS
const featList = document.getElementById('featList');
function renderFeats(sub='race'){
  const items = state.features[sub]||[];
  featList.innerHTML = items.map(n=>`<div class="row"><div class="name">${n}</div><div></div><div></div><div></div><div></div></div>`).join('')||'<div class="muted">No features.</div>';
}
renderFeats();
wireSubtabs('feat', renderFeats);

// DESCRIPTION
const descList = document.getElementById('descList');
function renderDesc(sub='bio'){
  const items = state.description[sub]||[];
  descList.innerHTML = items.map(n=>`<div class="row"><div class="name">${n}</div><div></div><div></div><div></div><div></div></div>`).join('')||'<div class="muted">No description.</div>';
}
renderDesc();
wireSubtabs('desc', renderDesc);

// NOTES
const notesList = document.getElementById('notesList');
function renderNotes(sub='session'){
  const items = state.notes[sub]||[];
  notesList.innerHTML = items.map(n=>`<div class="row"><div class="name">${n}</div><div></div><div></div><div></div><div></div></div>`).join('')||'<div class="muted">No notes.</div>';
}
renderNotes();
wireSubtabs('notes', renderNotes);

// EXTRAS
const extrasList = document.getElementById('extrasList');
function renderExtras(sub='pets'){
  const items = state.extras[sub]||[];
  extrasList.innerHTML = items.map(n=>`<div class="row"><div class="name">${n}</div><div></div><div></div><div></div><div></div></div>`).join('')||'<div class="muted">No extras.</div>';
}
renderExtras();
wireSubtabs('extras', renderExtras);
</script>
</body>
</html>
    background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/><feColorMatrix type='saturate' values='0'/></filter><rect width='100%' height='100%' filter='url(%23n)' opacity='0.55'/></svg>");
    opacity:var(--grain-strength, .12);
    mix-blend-mode:overlay;
  }
  @media (prefers-reduced-motion: no-preference){
    body::after{ animation: grainShift 8s linear infinite; }
  }
  @keyframes grainShift{ from{ transform:translate3d(0,0,0);} to{ transform:translate3d(-160px,-160px,0);} }

  header{
    display:flex;align-items:center;justify-content:space-between;padding:.6rem 1rem;
    border-bottom:1px solid var(--accent);background:rgba(10,10,14,.9);backdrop-filter:blur(6px);
    position:relative;z-index:20;
    box-shadow: 0 2px 20px rgba(230,197,127,.06);
  }
  .brand{display:flex;flex-direction:column}
  .brand .title{
    font-family:'Cinzel',serif;font-weight:900;letter-spacing:.06em;color:var(--gold);
    text-shadow:0 0 12px rgba(230,197,127,.35);font-size:1.4rem
  }
  .brand .byline{font-family:'Great Vibes',cursive;font-size:1.5rem;line-height:1;color:var(--gold)}
  .actions{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  .btn{
    background:rgba(35,35,45,.85);border:1px solid var(--accent);color:var(--ink);
    padding:.35rem .6rem;border-radius:8px;cursor:pointer
  }
  .btn:hover{background:var(--accent);color:#000;box-shadow:0 0 14px rgba(230,197,127,.35)}
  .btn.toggled{background:var(--accent);color:#000}
  input,select{
    background:#1c1b24;border:1px solid var(--accent);color:var(--ink);
    padding:.35rem;border-radius:6px;width:100%
  }

  #stage{flex:1;display:grid;grid-template-columns:320px 1fr 360px;min-height:0}
  #left-panel{
    background:var(--panel);border-right:1px solid var(--accent);overflow:auto;display:flex;flex-direction:column;
    box-shadow: inset 0 0 0 1px rgba(184,140,92,.22), inset 0 0 24px rgba(230,197,127,.06);
  }
  #right-panel{
    background:var(--panel);border-left:1px solid var(--accent);overflow:auto;
    box-shadow: inset 0 0 0 1px rgba(184,140,92,.22), inset 0 0 24px rgba(230,197,127,.06);
  }
  #map-container{position:relative;overflow:hidden;background:#111}

  .section{padding:12px;border-bottom:1px solid rgba(255,255,255,.06);position:relative;background:linear-gradient(180deg, rgba(235,220,185,.05), transparent 40%)}
  .section h3{margin:.1rem 0 .6rem;font-family:'Cinzel',serif;color:var(--gold);font-size:1rem;position:relative;padding-bottom:.35rem}
  .section h3::after{content:"";display:block;height:10px;margin:.35rem 0 0;background:radial-gradient(closest-side, var(--gold), transparent) left / 12px 10px no-repeat,radial-gradient(closest-side, var(--gold), transparent) right / 12px 10px no-repeat,linear-gradient(to right, transparent 0%, var(--gold) 15%, var(--gold) 85%, transparent 100%);opacity:.45}
  .row{display:flex;gap:.5rem;align-items:center;margin:.4rem 0}
  .row.stacked{flex-direction:column;align-items:stretch}

  #map{
    position:absolute;inset:0;object-fit:contain;width:100%;height:100%;
    transform-origin:top left;cursor:grab;z-index:1
  }

  /* Overlay layers (all are transformed with the map so fog/grid track pan/zoom) */
  canvas, .portal{position:absolute;left:0;top:0;pointer-events:none}
  #fx-layer{z-index:2}
  #grid-layer{z-index:3}
  #template-layer{z-index:4}
  #walls-layer{z-index:5}
  #fog-layer{z-index:6} /* keep fog below tokens */
  .token{
    position:absolute;border-radius:50%;background:#f44;color:#000;font-weight:800;
    display:flex;align-items:center;justify-content:center;user-select:none;cursor:grab;
    z-index:7;border:2px solid #fff;transform-origin:center;overflow:hidden
  }
  .token span{pointer-events:none}
  .token.has-img{background-size:cover;background-position:center;color:#fff;text-shadow:0 1px 2px #000}

  /* Portal */
  .portal{
    z-index:8; /* above fog */
    border:3px solid var(--gold);
    background:transparent;
    box-shadow:0 0 14px rgba(230,197,127,.35), inset 0 0 12px rgba(230,197,127,.18);
    border-radius:6px;
    pointer-events:auto; /* to catch right-click */
    transform-origin:top left;
  }

  #ctx{
    position:absolute;z-index:50;background:#1b1a22;border:1px solid var(--accent);
    border-radius:8px;overflow:hidden;display:none;min-width:200px
  }
  #ctx button{display:block;width:100%;text-align:left;padding:.5rem .7rem;background:transparent;color:var(--ink);border:none;cursor:pointer}
  #ctx button:hover{background:rgba(255,255,255,.08)}

  #submap-overlay{
    position:absolute;inset:0;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);display:none;z-index:30
  }
  .parchment{
    position:absolute;inset:6% 10%;background:var(--paper) url('https://i.imgur.com/2mJvRjF.png') center/cover no-repeat;
    box-shadow:0 20px 60px rgba(0,0,0,.6);border:2px solid var(--paperEdge);border-radius:14px;overflow:hidden
  }
  .parchment .head{
    display:flex;justify-content:space-between;align-items:center;padding:.4rem .6rem;
    background:linear-gradient(#f6eed9,#eadfbf);border-bottom:1px solid var(--paperEdge)
  }
  .parchment .head .ttl{font-family:'Cinzel',serif;color:#5a4829}
  .parchment .head .x{background:#7a1;color:#fff;border:none;padding:.3rem .55rem;border-radius:999px;cursor:pointer}
  .parchment .body{position:absolute;inset:42px 8px 8px 8px;background:#d7ccb0}
  #submap-canvas{position:absolute;inset:0}

  #token-forge{flex:1;overflow:auto}
  #forge-grid{display:grid;grid-template-columns:1fr;gap:.6rem}
  #saved-maps{
    max-height:200px;overflow:auto;border:1px solid rgba(255,255,255,.12);
    border-radius:8px;padding:.35rem
  }
  .map-item{display:flex;align-items:center;gap:.5rem;margin:.3rem 0}
  .thumb{width:42px;height:42px;background:#222;border:1px solid rgba(255,255,255,.12);background-size:cover;background-position:center;border-radius:6px}
  #initiative{margin-top:auto}

  .handle{position:absolute;width:10px;height:10px;border:2px solid #00c8ff;background:#00131a;border-radius:2px;z-index:9;pointer-events:auto}

  .ov-box{border:1px solid var(--paperEdge);border-radius:10px;background:rgba(235,220,185,.07);padding:.6rem}
  .ov-row{display:grid;grid-template-columns:100px 1fr;gap:.5rem;align-items:center;margin:.35rem 0}
  #ov-console{
    min-height:70px;max-height:160px;overflow:auto;background:#0e0d12;border:1px dashed var(--accent);
    padding:.5rem;border-radius:8px;font-family:ui-monospace,SFMono-Regular,Consolas,Menlo,monospace;font-size:.85rem
  }

  /* Previous Renders modal */
  #renders-modal{
    position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:60
  }
  #renders-dialog{
    width:min(920px,90vw);max-height:80vh;overflow:auto;background:#14131a;border:1px solid var(--accent);border-radius:12px;
    box-shadow:0 30px 80px rgba(0,0,0,.65);padding:12px
  }
  .rl-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
  @media (max-width:980px){ .rl-grid{grid-template-columns:repeat(2,1fr)} }
  @media (max-width:620px){ .rl-grid{grid-template-columns:1fr} }
  .rl-card{border:1px solid rgba(255,255,255,.12);border-radius:10px;overflow:hidden;background:#0f0f14}
  .rl-shot{height:160px;background:#222 center/cover no-repeat}
  .rl-meta{padding:.5rem;border-top:1px solid rgba(255,255,255,.06)}
  .rl-actions{display:flex;gap:.4rem;padding:.5rem;border-top:1px solid rgba(255,255,255,.06)}

  /* Help popover */
  #ov-help{
    position:absolute;top:100%;left:50%;transform:translateX(-50%);
    width:420px;background:#14131a;border:1px solid var(--accent);border-radius:12px;
    color:var(--ink);font-size:.9rem;line-height:1.4;box-shadow:0 20px 50px rgba(0,0,0,.6);
    z-index:50;padding:1rem;display:none;
  }
  #ov-help::before{
    content:"";position:absolute;top:-10px;left:50%;transform:translateX(-50%);
    border:5px solid transparent;border-bottom:5px solid var(--accent);
  }
  #ov-help h4{color:var(--gold);margin:.2rem 0; font-size:1rem}
  #ov-help ul{margin:.5rem 0; padding-left:1.2rem }

  /* While painting fog, route pointer events to fog canvas */
  .fog-edit .token, .fog-edit .portal { pointer-events: none !important; }
  #fog-layer.fog-active { z-index: 100 !important; pointer-events: auto !important; }

  :root{ /* optional texture + UI tuning */
    --bg-art: url("assets/bg-etched-stone.webp");
    --bg-vignette: radial-gradient(65% 65% at 50% 55%, rgba(0,0,0,0) 55%, rgba(0,0,0,.6) 100%);
    --grain-strength: .12;
    /* inline SVG for gold frame */
    --gold-frame: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' preserveAspectRatio='none'><defs><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop offset='0' stop-color='%23e6c57f'/><stop offset='.5' stop-color='%23b88c5c'/><stop offset='1' stop-color='%237d5d38'/></linearGradient></defs><path d='M1,1 H11 V11 H1 Z' fill='none' stroke='url(%23g)' stroke-width='1.2'/></svg>");
  }

  /* Ornate gold border-image on main frames */
  #left-panel, #right-panel, #renders-dialog, .parchment{
    border:12px solid transparent;
    border-image-source: var(--gold-frame);
    border-image-slice: 4 fill;
    border-image-width: 12;
    border-image-repeat: stretch;
  }

  /* Subtle separators inside lists */
  .map-item{ position:relative; padding:6px 0; }
  .map-item + .map-item{ border-top:1px dashed rgba(255,255,255,.10); }

  /* Decorative parchment corners */
  .parchment::before,
  .parchment::after{
    content:""; position:absolute; width:36px; height:36px;
    background: radial-gradient(closest-side, rgba(0,0,0,.35), transparent 70%),
                conic-gradient(from 45deg, rgba(230,197,127,.55), transparent 75%);
    filter: blur(.3px); opacity:.6;
  }
  .parchment::before{ left:-10px; top:-10px; border-radius:12px; }
  .parchment::after{ right:-10px; bottom:-10px; border-radius:12px; transform: scaleX(-1) scaleY(-1); }

  @media (max-width:1180px){
    #stage{grid-template-columns:0 1fr 360px}
    #left-panel{display:none}
  }
</style>
<link rel="preload" as="image" href="assets/bg-etched-stone.webp" imagesizes="100vw">
</head>
<body>
<header>
  <div class="brand">
    <div class="title">The War Vault</div>
    <div class="byline">Chris Marshall</div>
  </div>
  <div class="actions" id="top-actions">
    <button id="btn-zoom-in" class="btn" type="button" title="Zoom in">Ôºã</button>
    <button id="btn-zoom-out" class="btn" type="button" title="Zoom out">Ôºç</button>
    <input id="map-upload" type="file" accept="image/*" class="btn" title="Upload map" />
    <button id="btn-save-map" class="btn" type="button" title="Save map">üíæ Save</button>
    <button id="btn-open-renders" class="btn" type="button" title="Previous renders">üñºÔ∏è Previous</button>
  </div>
</header>

<div id="stage">
  <aside id="left-panel">
    <div class="section" id="token-forge">
      <h3>Token Forge</h3>
      <div id="forge-grid">
        <div>
          <div class="row"><input id="tf-name" placeholder="Name" /></div>
          <div class="row">
            <label for="tf-color" style="min-width:60px">Color</label>
            <input id="tf-color" type="color" value="#ff4444" />
          </div>
          <div class="row">
            <label for="tf-size" style="min-width:60px">Size (px)</label>
            <input id="tf-size" type="number" min="24" max="120" value="42" />
          </div>
          <div class="row"><input id="tf-photo" type="file" accept="image/*" /></div>
          <div class="row"><button id="btn-create-token" class="btn" type="button" style="width:100%">‚ûï Create Token</button></div>
        </div>
        <div>
          <div style="margin-bottom:.3rem;color:#cbb27d">Saved Sessions</div>
          <div id="saved-maps"></div>
        </div>
      </div>
    </div>

    <div class="section" id="initiative">
      <h3>Initiative</h3>
      <div class="row">
        <input id="init-name" placeholder="Name" aria-label="Initiative name">
        <input id="init-roll" type="number" placeholder="Roll" style="max-width:90px" aria-label="Initiative roll">
      </div>
      <div class="row">
        <button id="btn-init-add" class="btn" type="button" style="width:100%">Add</button>
      </div>
      <div class="row" style="gap:.5rem">
        <button id="btn-init-next" class="btn" type="button" style="flex:1">Next</button>
        <button id="btn-init-reset" class="btn" type="button" style="flex:1">Reset</button>
      </div>
      <div id="init-list" style="margin-top:.5rem"></div>
    </div>
  </aside>

  <main id="map-container">
    <img id="map" src="https://i.imgur.com/8V7V3sP.jpg" alt="Map" />
    <canvas id="fx-layer"></canvas>
    <canvas id="grid-layer"></canvas>
    <canvas id="template-layer"></canvas>
    <canvas id="walls-layer"></canvas>
    <canvas id="fog-layer"></canvas>

    <div id="ctx" role="menu">
      <button data-act="sheet" type="button">View Character Sheet</button>
      <button data-act="assign-submap" type="button">Assign Submap‚Ä¶</button>
      <button data-act="open-submap" type="button">Open Submap</button>
      <button data-act="delete" type="button">Delete</button>
    </div>

    <div id="submap-overlay" aria-hidden="true">
      <div class="parchment" role="dialog" aria-modal="true" aria-labelledby="submap-title">
        <div class="head">
          <div class="ttl" id="submap-title">Submap</div>
          <button class="x" id="close-submap" type="button" aria-label="Close">‚úï</button>
        </div>
        <div class="body">
          <canvas id="submap-canvas"></canvas>
        </div>
      </div>
    </div>
  </main>

  <aside id="right-panel">
    <div class="section">
      <h3>Tools</h3>
      <div class="row" style="flex-wrap:wrap">
        <button class="btn tool" type="button" data-tool="pan">üñêÔ∏è Pan</button>
        <button class="btn tool" type="button" data-tool="select">üñ±Ô∏è Select</button>
        <button class="btn tool" type="button" data-tool="ruler">üìè Ruler</button>
        <button class="btn tool" type="button" data-tool="circle">‚≠ï Circle</button>
        <button class="btn tool" type="button" data-tool="cone">üî∫ Cone</button>
        <button class="btn tool" type="button" data-tool="wall">üß± Wall</button>
        <button class="btn tool" type="button" data-tool="portal">üåÄ Portal</button>
      </div>
      <div class="row">
        <button id="btn-clear-templates" class="btn" type="button" style="flex:1">Clear Templates</button>
        <label style="display:flex;align-items:center;gap:.35rem"><input type="checkbox" id="snap" /> Snap-to-grid</label>
      </div>
      <div class="row">
        <select id="fog-mode" aria-label="Fog mode">
          <option value="none">Fog: off</option>
          <option value="reveal">Fog: reveal</option>
          <option value="hide">Fog: hide</option>
        </select>
        /* ==== Fit canvases (HiDPI) ==== */
function fitCanvases() {
  const r = wrap.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  [fx, grid, tpl, wallsLayer, fog].forEach(cv => {
    cv.width  = Math.max(1, Math.floor(r.width  * dpr));
    cv.height = Math.max(1, Math.floor(r.height * dpr));
    cv.style.width  = r.width + 'px';
    cv.style.height = r.height + 'px';
  });

  fxx.setTransform(dpr, 0, 0, dpr, 0, 0);
  gctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  tctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  wctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  fctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  drawGrid();
  drawWalls();
  drawTemplates();
  drawFX();
  drawFogToScreen();
  repositionAll();
}
let resizeRAF = 0;
window.addEventListener('resize', () => {
  cancelAnimationFrame(resizeRAF);
  resizeRAF = requestAnimationFrame(fitCanvases);
});

  const tfName  = document.getElementById('tf-name');
  // Fog: Undo
fogUndoBtn.addEventListener('click', () => {
  if (fogUndoStack.length < 2) return;
  const prev = fogUndoStack.pop();
  try { fogRedoStack.push(fogx.getImageData(0,0,fogTex.width,fogTex.height)); } catch {}
  try { fogx.putImageData(prev,0,0); } catch {}
  drawFogToScreen();
});

// Fog: Redo
fogRedoBtn.addEventListener('click', () => {
  if (!fogRedoStack.length) return;
  const img = fogRedoStack.pop();
  try { fogUndoStack.push(fogx.getImageData(0,0,fogTex.width,fogTex.height)); } catch {}
  try { fogx.putImageData(img,0,0); } catch {}
  drawFogToScreen();
});

  const initAdd  = document.getElementById('btn-init-add');
  const initNext = document.getElementById('btn-init-next');
  const initReset= document.getElementById('btn-init-reset');
  const initList = document.getElementById('init-list');

  /* Omniverse bits (bridge optional) */
  const ovUrl = document.getElementById('ov-url');
  const ovUsd = document.getElementById('ov-usd');
  const ovRes = document.getElementById('ov-res');
  const ovFormat = document.getElementById('ov-format');
  const ovConnect = document.getElementById('ov-connect');
  const ovGenerate= document.getElementById('ov-generate');
  const ovRefresh = document.getElementById('ov-refresh');
  const ovOpenLibrary = document.getElementById('ov-open-library');
  const ovConsole = document.getElementById('ov-console');
  const ovHelpBtn = document.getElementById('ov-help-btn');
  const ovHelp    = document.getElementById('ov-help');

  /* Previous Renders modal */
  const openRendersBtn = document.getElementById('btn-open-renders');
  const rendersModal   = document.getElementById('renders-modal');
  const rendersClose   = document.getElementById('renders-close');
  // Fog: Undo
fogUndoBtn.addEventListener('click', () => {
  if (fogUndoStack.length < 2) return;
  const prev = fogUndoStack.pop();
  try { fogRedoStack.push(fogx.getImageData(0,0,fogTex.width,fogTex.height)); } catch {}
  try { fogx.putImageData(prev,0,0); } catch {}
  drawFogToScreen();
});

// Fog: Redo
fogRedoBtn.addEventListener('click', () => {
  if (!fogRedoStack.length) return;
  const img = fogRedoStack.pop();
  try { fogUndoStack.push(fogx.getImageData(0,0,fogTex.width,fogTex.height)); } catch {}
  try { fogx.putImageData(img,0,0); } catch {}
  drawFogToScreen();
});

  let sessions= JSON.parse(localStorage.getItem('warvault-maps')    || '[]');

  let currentTool = 'pan';

  // Unified action state to prevent conflicting listeners
  let action = null; // { type: 'pan'|'draw'|'token'|'portal'|'fog', ... }

  let selectedToken = null;
  let selectedPortal= null;
  let drawingWall = null; // {points:[], type}

  /* Fog-of-war in world space */
  let fogTex = document.createElement('canvas');
  let fogx   = fogTex.getContext('2d');
  const FOG_LIMIT = 20;
  let fogUndoStack = [];
  let fogRedoStack = [];

  /* FX */
  let noiseTile = null;

  /* Initiative */
  let initiative = [];
  let initIdx = -1;

  /* WebSocket bridge (optional) */
  let ws = null;

  /* ==== Helpers ==== */
  const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
  function screenToWorld(sx, sy)  { return { x: (sx - offset.x) / scale, y: (sy - offset.y) / scale }; }
  function worldToScreen(wx, wy)  { return { x: offset.x + wx * scale,   y: offset.y + wy * scale   }; }
  function snap(v) { return document.getElementById('snap').checked ? Math.round(v / cell) * cell : v; }
  function pointerToWrap(e){ const r = wrap.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }

  /* ==== Fit canvases (HiDPI) ==== */
  function fitCanvases() {
    const r = wrap.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

// Fog: Undo
fogUndoBtn.addEventListener('click', () => {
  if (fogUndoStack.length < 2) return;
  const prev = fogUndoStack.pop();
  try { fogRedoStack.push(fogx.getImageData(0,0,fogTex.width,fogTex.height)); } catch {}
  try { fogx.putImageData(prev,0,0); } catch {}
  drawFogToScreen();
});

    tctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    wctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    fctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    drawGrid();
    drawWalls();
    drawTemplates();
    drawFX();
    drawFogToScreen();
    repositionAll();
  }
  let resizeRAF = 0;
  window.addEventListener('resize', () => {
    cancelAnimationFrame(resizeRAF);
    resizeRAF = requestAnimationFrame(fitCanvases);
  });

  /* Grid */
  function drawGrid() {
    const dpr = window.devicePixelRatio || 1;
    const w = grid.width / dpr, h = grid.height / dpr;
    gctx.clearRect(0,0,w,h);
    gctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--rune');
    gctx.lineWidth = 1;
    const step = cell;
    for (let x=0; x<w; x+=step){ gctx.beginPath(); gctx.moveTo(x,0); gctx.lineTo(x,h); gctx.stroke(); }
    for (let y=0; y<h; y+=step){ gctx.beginPath(); gctx.moveTo(0,y); gctx.lineTo(w,y); gctx.stroke(); }
  }

  /* Background FX */
  function makeNoiseTile(){
    const c = document.createElement('canvas');
    c.width = c.height = 128;
    const x = c.getContext('2d');
    const img = x.createImageData(c.width, c.height);
    for (let i=0;i<img.data.length;i+=4){
      const v = 200 + Math.random()*55;
      img.data[i]=img.data[i+1]=img.data[i+2]=v;
      img.data[i+3]=10;
    }
    x.putImageData(img,0,0);
    return c;
  }
  function drawFX(){
    const w = fx.clientWidth, h = fx.clientHeight;
    fxx.clearRect(0,0,w,h);
    const g = fxx.createRadialGradient(w*0.5,h*0.55, Math.min(w,h)*0.15, w*0.5,h*0.55, Math.max(w,h)*0.65);
    g.addColorStop(0,'rgba(0,0,0,0)');
    g.addColorStop(1,'rgba(0,0,0,0.45)');
    fxx.globalCompositeOperation='multiply';
    fxx.fillStyle=g; fxx.fillRect(0,0,w,h);
    if(!noiseTile) noiseTile = makeNoiseTile();
    const p = fxx.createPattern(noiseTile,'repeat');
    fxx.globalCompositeOperation='overlay'; fxx.globalAlpha=0.35;
    fxx.fillStyle=p; fxx.fillRect(0,0,w,h);
    fxx.globalAlpha=1; fxx.globalCompositeOperation='source-over';
  }
  mapEl.style.filter = 'contrast(1.06) saturate(1.08) brightness(1.02)';

  /* Reposition (apply same transform to overlays so fog/grid/etc track) */
  function applyTransform(el){
    el.style.transform = `translate(${offset.x}px, ${offset.y}px) scale(${scale})`;
    el.style.transformOrigin = 'top left';
  }
  function repositionAll() {
    applyTransform(mapEl);
    [fx, grid, tpl, wallsLayer, fog].forEach(applyTransform);
    tokens.forEach(t=>{
      const s = worldToScreen(t.x, t.y);
      t.el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
      t.el.style.transformOrigin = 'top left';
    function pushFogState() {
  try {
    const img = fogx.getImageData(0, 0, fogTex.width, fogTex.height);
    fogUndoStack.push(img);
    if (fogUndoStack.length > FOG_LIMIT) fogUndoStack.shift();
    fogRedoStack = [];
  } catch (e) {
    console.warn('Fog undo snapshot failed', e);
  }
}

    repositionAll();
  }
  zoomInBtn.addEventListener('click', () => setScale(scale * 1.2));
  zoomOutBtn.addEventListener('click', () => setScale(scale / 1.2));
  wrap.addEventListener('wheel', e => {
    e.preventDefault();
    setScale(scale * (e.deltaY < 0 ? 1.15 : 0.87), e.offsetX, e.offsetY);
  }, { passive: false });

  /* Map upload */
  mapUpload.addEventListener('change', e => {
    const file = e.target.files?.[0];
    if (!file) return;
    const r = new FileReader();
    r.onload = ev => {
      mapEl.onload = () => {
        resetFogWorld();
        fitCanvases();
      };
      mapEl.src = ev.target.result;
    };
    r.onerror = () => alert("Failed to load image");
    r.readAsDataURL(file);
  });

  function pushFogState() {
  try {
    const img = fogx.getImageData(0, 0, fogTex.width, fogTex.height);
    fogUndoStack.push(img);
    if (fogUndoStack.length > FOG_LIMIT) fogUndoStack.shift();
    fogRedoStack = [];
  } catch (e) {
    console.warn('Fog undo snapshot failed', e);
  }
}

  function resetFogWorld(){
    const w = wrap.clientWidth  || 1;
    const h = wrap.clientHeight || 1;
    fogTex.width  = w;
    fogTex.height = h;
    fogx = fogTex.getContext('2d');
    fogx.clearRect(0,0,w,h);
    fogUndoStack = []; fogRedoStack = [];
    pushFogState();
  }
  function pushFogState() {
    try {
          } else {
      alert('Nothing selected with an assigned submap.');
    }

  /* TEMPLATES (ruler/circle/cone) */
  function drawTemplates(){
    const dpr = window.devicePixelRatio || 1;
    const w = tpl.width / dpr, h = tpl.height / dpr;
    tctx.clearRect(0,0,w,h);
    tctx.lineWidth = Math.max(2, 2*scale);
    tctx.strokeStyle = '#80d8ff';
    tctx.fillStyle = 'rgba(128,216,255,.15)';

    const render = (t)=>{
      if (t.type==='ruler'){
        const a=worldToScreen(t.start.x,t.start.y), b=worldToScreen(t.end.x,t.end.y);
        tctx.beginPath(); tctx.moveTo(a.x,a.y); tctx.lineTo(b.x,b.y); tctx.stroke();
      } else if (t.type==='circle'){
        const c=worldToScreen(t.start.x,t.start.y);
        tctx.beginPath(); tctx.arc(c.x,c.y, t.r*scale, 0, Math.PI*2); tctx.fill(); tctx.stroke();
      } else if (t.type==='cone'){
        const c=worldToScreen(t.start.x,t.start.y);
        tctx.beginPath();
        tctx.moveTo(c.x,c.y);
        tctx.arc(c.x,c.y, t.r*scale, t.a0, t.a1);
        tctx.closePath(); tctx.fill(); tctx.stroke();
      }
    };
    templates.forEach(render);
    if (action && action.type==='draw' && action.draft) render(action.draft);
  }
  clearTplBtn.addEventListener('click', ()=>{ templates=[]; drawTemplates(); });

  /* WALLS */
  function drawWalls(){
    const dpr = window.devicePixelRatio || 1;
    const w = wallsLayer.width / dpr, h = wallsLayer.height / dpr;
    wctx.clearRect(0,0,w,h);
    wctx.lineWidth = Math.max(2, 2*scale);
    walls.forEach(seg=>{
      const A=worldToScreen(seg.a.x,seg.a.y), B=worldToScreen(seg.b.x,seg.b.y);
      wctx.strokeStyle = seg.type==='door' ? (seg.open?'#4caf50':'#ffc107') :
                         seg.type==='window' ? '#80d8ff' : '#ff7961';
      wctx.beginPath(); wctx.moveTo(A.x,A.y); wctx.lineTo(B.x,B.y); wctx.stroke();
    });
    if (drawingWall?.points?.length){
      wctx.strokeStyle='#ffd54f'; wctx.setLineDash([6,6]);
      drawingWall.points.forEach((p,i)=>{
        const s=worldToScreen(p.x,p.y);
        if(i===0) wctx.beginPath(), wctx.moveTo(s.x,s.y); else wctx.lineTo(s.x,s.y);
      });
      wctx.stroke(); wctx.setLineDash([]);
    }
  }
  function ccw(A,B,C){ return (C.y-A.y)*(B.x-A.x) > (B.y-A.y)*(C.x-A.x); }
  function segIntersect(a,b,c,d){ return ccw(a,c,d) !== ccw(b,c,d) && ccw(a,b,c) !== ccw(a,b,d); }
  function moveBlocked(from, to){
    for (const w of walls){
      if (w.type==='door' && w.open) continue;
      if (segIntersect(from, to, w.a, w.b)) return true;
    }
    return false;
  }

  /* TOKENS */
  function addToken({name,color,size,img,x,y,sheet}){
    const el = document.createElement('div');
    el.className = 'token';
    el.style.width = el.style.height = (size||42)+'px';
    el.style.background = color || '#f44';
    el.innerHTML = '<span>'+ (name||'T') +'</span>';
    if (img){ el.classList.add('has-img'); el.style.backgroundImage = `url(${img})`; }
    wrap.appendChild(el);
    const t = {el, name, color, size: size||42, x: x??100, y: y??100, img, sheet: sheet||null};
    tokens.push(t);
    const s = worldToScreen(t.x,t.y);
    el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    el.style.transformOrigin = 'top left';
    return t;
  }
  createTokenBtn.addEventListener('click', ()=>{
    const name = tfName.value.trim()||'T';
    const color= tfColor.value;
    const size = clamp(parseInt(tfSize.value||42,10), 24, 120);
    if (tfPhoto.files?.[0]){
      const r = new FileReader();
      r.onload = ev => addToken({name,color,size,img:ev.target.result});
      r.readAsDataURL(tfPhoto.files[0]);
    } else {
      addToken({name,color,size});
    }
  });

  /* PORTALS */
  function makePortal(x,y,w,h,targetName){
    const el = document.createElement('div');
    el.className = 'portal';
    el.style.width = Math.max(1,w) + 'px';
    el.style.height = Math.max(1,h) + 'px';
    wrap.appendChild(el);
    const p = {el, x, y, w:Math.max(1,w), h:Math.max(1,h), targetName: targetName||null};
    portals.push(p);
    const s = worldToScreen(x,y);
    el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    el.style.transformOrigin = 'top left';
    el.addEventListener('mousedown', (e)=>{
      if (currentTool!=='select') return;
      selectedPortal = p; selectedToken=null;
      e.preventDefault();
    });
    el.addEventListener('dblclick', ()=>{
      if (p.targetName){
        const s = submaps.find(x=>x.name===p.targetName);
        if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
      } else {
        promptAssignPortal(p);
      }
    });
    return p;
  }
  function promptAssignPortal(p){
    if (!submaps.length){ alert('No submaps in library. Add one on the right.'); return; }
    const pick = prompt('Assign to submap (type name):
'+ submaps.map(s=>s.name).join('
'));
    if (!pick) return;
    const exists = submaps.find(s=>s.name===pick);
    if (!exists) { alert('Not found.'); return; }
    p.targetName = pick;
  }

  /* CONTEXT MENU */
  wrap.addEventListener('contextmenu', (e)=>{
    e.preventDefault();
    // detect if portal or token clicked
    selectedPortal = null; selectedToken=null;
    const el = e.target.closest('.portal,.token');
    if (el?.classList.contains('portal')){
      selectedPortal = portals.find(p=>p.el===el) || null;
    } else if (el?.classList.contains('token')){
      selectedToken  = tokens.find(t=>t.el===el) || null;
    }
    ctxMenu.style.display='block';
    ctxMenu.style.left = e.clientX+'px';
    ctxMenu.style.top  = e.clientY+'px';
  });
  window.addEventListener('click', (e)=>{
    if (!ctxMenu.contains(e.target)) ctxMenu.style.display='none';
  });

  ctxMenu.addEventListener('click', (e)=>{
    const act = e.target.getAttribute('data-act');
    if (!act) return;
    ctxMenu.style.display='none';
    if (act==='delete'){
      if (selectedPortal){
        selectedPortal.el.remove();
        portals = portals.filter(p=>p!==selectedPortal);
        selectedPortal=null;
      } else if (selectedToken){
        selectedToken.el.remove();
        tokens = tokens.filter(t=>t!==selectedToken);
        selectedToken=null;
      }
    } else if (act==='assign-submap'){
      const names = submaps.map(s=>s.name);
      if (!names.length) return alert('No submaps in library. Add one on the right.');
      const pick = prompt('Assign to submap (type name):\n'+names.join('\n'));
      if (!pick) return;
      const exists = submaps.find(s=>s.name===pick);
      if (!exists) return alert('Not found.');
      if (selectedPortal) selectedPortal.targetName = pick;
      if (selectedToken)  selectedToken.sheet = { submap: pick };
    } else if (act==='open-submap'){
      if (selectedPortal && selectedPortal.targetName){
        const s = submaps.find(x=>x.name===selectedPortal.targetName);
        if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
      } else if (selectedToken && selectedToken.sheet?.submap){
        const s = submaps.find(x=>x.name===selectedToken.sheet.submap);
        if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
      } else {
        function startDraw(e){
  const pt = pointerToWrap(e);
  const pos = screenToWorld(pt.x, pt.y);
  const sx = snap(pos.x), sy = snap(pos.y);
  if (currentTool==='ruler'){
    action = { type:'draw', draft:{type:'ruler', start:{x:sx,y:sy}, end:{x:sx,y:sy}} };
  } else if (currentTool==='circle'){
    action = { type:'draw', draft:{type:'circle', start:{x:sx,y:sy}, r:1} };
  } else if (currentTool==='cone'){
    action = { type:'draw', draft:{type:'cone', start:{x:sx,y:sy}, r:1, a0:0, a1:0} };
  } else if (currentTool==='wall'){
    if (!drawingWall) drawingWall = {points:[], type:'wall'};
    drawingWall.points.push({x:sx,y:sy});
    drawWalls();
  } else if (currentTool==='portal'){
    action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ 
      const g = document.createElement('div'); 
      g.className = 'portal'; 
      g.style.width = '1px'; 
      g.style.height = '1px'; 
      wrap.appendChild(g); 
      return g;
    })() };
    const s = worldToScreen(sx, sy);
    action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
  }
}
      if (!drawingWall) drawingWall = {points:[], type:'wall'};
      drawingWall.points.push({x:sx,y:sy});
      drawWalls();
    } else if (currentTool==='portal'){
      action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ const g=document.createElement('div'); g.className='portal'; g.style.width='1px'; g.style.height='1px'; wrap.appendChild(g); return g;})() };
      const s = worldToScreen(sx, sy);
      action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    }
  }

  /* SUBMAPS */
  const subOverlay = document.getElementById('submap-overlay');
  const subCanvas  = document.getElementById('submap-canvas');
  const subCtx     = subCanvas.getContext('2d');
  function openSubmap(imgSrc, title='Submap'){
    document.getElementById('submap-title').textContent = title;
    subOverlay.style.display = 'block';
    subOverlay.setAttribute('aria-hidden','false');

    const img = new Image();
    img.onload = ()=>{
      requestAnimationFrame(()=>{
        const dpr = window.devicePixelRatio || 1;
        const w = subCanvas.clientWidth || 1;
        const h = subCanvas.clientHeight || 1;
        subCanvas.width = Math.floor(w * dpr);
        subCanvas.height= Math.floor(h * dpr);
        subCtx.setTransform(dpr,0,0,dpr,0,0);

        const ratio = Math.max(w/img.width, h/img.height);
        const dw = img.width*ratio, dh = img.height*ratio;
        const dx = (w - dw)/2, dy = (h - dh)/2;
        subCtx.clearRect(0,0,w,h);
        subCtx.drawImage(img, dx, dy, dw, dh);
      });
    };
    img.src = imgSrc;
  }
  document.getElementById('close-submap').addEventListener('click', ()=>{
    subOverlay.style.display='none';
    subOverlay.setAttribute('aria-hidden','true');
  });
  subAddBtn.addEventListener('click', ()=>{
    const file = subFile.files?.[0];
    const name = (subName.value.trim()||'Submap');
    if (!file) return alert('Choose an image');
    const r = new FileReader();
    r.onload = ev=>{
      submaps.push({name, img: ev.target.result});
      localStorage.setItem('warvault-submaps', JSON.stringify(submaps));
      renderSubmaps();
    };
    r.readAsDataURL(file);
  });
  function renderSubmaps(){
    subList.innerHTML='';
    submaps.forEach((s,i)=>{
      const row = document.createElement('div');
      row.className='map-item';
      row.innerHTML = `
        <div class="thumb" style="background-image:url('${s.img}')"></div>
        <div style="flex:1">
          <div>${s.name}</div>
        </div>
        <button class="btn" data-i="${i}" data-act="open">Open</button>
        <button class="btn" data-i="${i}" data-act="del">Delete</button>
      `;
      row.querySelector('[data-act="open"]').onclick = ()=> openSubmap(s.img, s.name);
      row.querySelector('[data-act="del"]').onclick  = ()=>{
        submaps.splice(i,1);
        localStorage.setItem('warvault-submaps', JSON.stringify(submaps));
        renderSubmaps();
function startDraw(e){
  const pt = pointerToWrap(e);
  const pos = screenToWorld(pt.x, pt.y);
  const sx = snap(pos.x), sy = snap(pos.y);
  if (currentTool==='ruler'){
    action = { type:'draw', draft:{type:'ruler', start:{x:sx,y:sy}, end:{x:sx,y:sy}} };
  } else if (currentTool==='circle'){
    action = { type:'draw', draft:{type:'circle', start:{x:sx,y:sy}, r:1} };
  } else if (currentTool==='cone'){
    action = { type:'draw', draft:{type:'cone', start:{x:sx,y:sy}, r:1, a0:0, a1:0} };
  } else if (currentTool==='wall'){
    if (!drawingWall) drawingWall = {points:[], type:'wall'};
    drawingWall.points.push({x:sx,y:sy});
    drawWalls();
  } else if (currentTool==='portal'){
    action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ 
      const g = document.createElement('div'); 
      g.className = 'portal'; 
      g.style.width = '1px'; 
      g.style.height = '1px'; 
      wrap.appendChild(g); 
      return g;
    })() };
    const s = worldToScreen(sx, sy);
    action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
  }
}
      return;
    }
    sessions.slice().reverse().forEach((m, idxFromEnd)=>{
      const idx = sessions.length-1-idxFromEnd;
      const row = document.createElement('div');
      row.className='map-item';
      row.innerHTML = `
        <div class="thumb" style="background-image:url('${m.thumb||m.map?.src||""}')"></div>
        <div style="flex:1">
          <div>${m.name || 'Session'} ‚Äî ${new Date(m.when).toLocaleString()}</div>
        </div>
        <button class="btn" data-act="load">Load</button>
        <button class="btn" data-act="remove">Delete</button>
      `;
      row.querySelector('[data-act="load"]').onclick = ()=> loadSession(m);
      row.querySelector('[data-act="remove"]').onclick = ()=>{
        sessions.splice(idx,1);
        localStorage.setItem('warvault-maps', JSON.stringify(sessions));
        renderSaved();
      };
      savedMapsDiv.appendChild(row);
    });
  }
  function collectSession(){
    return {
      when: Date.now(),
      name: 'WarVault Session',
      map: { src: mapEl.src },
      fog: fogTex.toDataURL('image/webp', 0.85),
      tokens: tokens.map(t=>({name:t.name,color:t.color,size:t.size,x:t.x,y:t.y,img:t.img||null,sheet:t.sheet||null})),
      portals: portals.map(p=>({x:p.x,y:p.y,w:p.w,h:p.h,targetName:p.targetName||null})),
      walls: walls.map(w=>({a:w.a,b:w.b,type:w.type,open:w.open})),
      templates,
      settings: { cell, scale, offset }
    };
  }
  function applySessionState(s){
    resetFogWorld();
    // fog
    if (s.fog){
      const img=new Image(); img.onload=()=>{
        fogx.clearRect(0,0,fogTex.width,fogTex.height);
        fogx.drawImage(img,0,0, fogTex.width, fogTex.height);
        drawFogToScreen();
      }; img.src=s.fog;
    } else { drawFogToScreen(); }

    // tokens
    tokens.forEach(t=>t.el.remove()); tokens=[];
    (s.tokens||[]).forEach(t=> addToken(t));

    // portals
    portals.forEach(p=>p.el.remove()); portals=[];
    (s.portals||[]).forEach(p=> makePortal(p.x,p.y,p.w,p.h,p.targetName||null));

    // walls
    walls = (s.walls||[]).map(w=>({a:w.a,b:w.b,type:w.type||'wall',open:!!w.open}));
    drawWalls();

    // templates
    templates = s.templates || [];
    drawTemplates();

    // settings
    if (s.settings){
      offset = s.settings.offset || {x:0,y:0};
      scale  = s.settings.scale  || 1;
    }
    repositionAll();
    drawFX();
    fitCanvases();
    setTool('pan');
  }
  function} else if (act==='open-submap'){
  if (selectedPortal && selectedPortal.targetName){
    const s = submaps.find(x=>x.name===selectedPortal.targetName);
    if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
  } else if (selectedToken && selectedToken.sheet?.submap){
    const s = submaps.find(x=>x.name===selectedToken.sheet.submap);
    if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
  } else {
    alert('Nothing selected with an assigned submap.');
  }
}

      applySessionState(s);
      return;
    }

    mapEl.onload = ()=>{ applySessionState(s); };

    // Force reload if same src to ensure onload fires on some browsers
    if (same){
      mapEl.src = '';
      setTimeout(()=>{ mapEl.src = targetSrc; }, 0);
    } else {
      mapEl.src = targetSrc;
    }
  }

  saveMapBtn.addEventListener('click', ()=>{
    const snap = collectSession();
    snap.thumb = mapEl.src;
    sessions.push(snap);
    try{
      localStorage.setItem('warvault-maps', JSON.stringify(sessions));
      renderSaved();
      alert('Session saved locally.');
    } catch(e){
      console.error(e);
      alert('Save failed (storage full?). Delete older sessions and try again.');
      sessions.pop();
    }
  });
  renderSaved();

  /* Initiative */
} else if (act==='open-submap'){
  if (selectedPortal && selectedPortal.targetName){
    const s = submaps.find(x=>x.name===selectedPortal.targetName);
    if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
  } else if (selectedToken && selectedToken.sheet?.submap){
    const s = submaps.find(x=>x.name===selectedToken.sheet.submap);
    if (s) openSubmap(s.img, s.name); else alert('Assigned submap not found.');
  } else {
    alert('Nothing selected with an assigned submap.');
  }
}

      row.querySelector('button').onclick = ()=>{
        initiative.splice(idx,1);
        if (initIdx >= initiative.length) initIdx = initiative.length-1;
        renderInit();
      };
      initList.appendChild(row);
    });
  }
  initAdd.onclick = ()=>{
    const name = initName.value.trim();
    const roll = parseInt(initRoll.value,10);
    if (!name || !Number.isFinite(roll)) return;
    initiative.push({name, roll});
    initiative.sort((a,b)=>b.roll-a.roll);
    initName.value=''; initRoll.value='';
    if (initIdx===-1) initIdx=0;
    renderInit();
  };
  initNext.onclick = ()=>{
    if (!initiative.length) return;
    initIdx = (initIdx+1)%initiative.length;
    renderInit();
  };
  initReset.onclick = ()=>{ initiative=[]; initIdx=-1; renderInit(); };

  /* Omniverse bridge (optional) */
  function logOv(msg) {
    ovConsole.innerHTML += `<div>${new Date().toLocaleTimeString()} ‚Äî ${msg}</div>`;
    ovConsole.scrollTop = ovConsole.scrollHeight;
  }
  function ensureWS(){
    if (ws && (ws.readyState===WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING)) return;
    ws = new WebSocket('ws://localhost:8080/omniverse');
    ws.onopen = ()=> logOv("Bridge connected");
    ws.onclose = ()=> logOv("Bridge disconnected");
    ws.onerror = ()=> logOv("Bridge error");
    ws.onmessage = (e)=>{
      try {
        const msg = JSON.parse(e.data);
        if (msg.type === 'map') {
          mapEl.onload = ()=>{ resetFogWorld(); fitCanvases(); };
          mapEl.src = msg.image;
          logOv("Map loaded.");
        } else if (msg.type === 'list') {
          buildLibrary(msg.items||[]);
        } else if (msg.type === 'error') {
          logOv("Error: " + msg.message); alert(msg.message);
        } else if (msg.type === 'info') {
          logOv(msg.message||'Info');
        }
      } catch { /* ignore */ }
    };
  }
  ovHelpBtn.onclick = () => { ovHelp.style.display = ovHelp.style.display === 'block' ? 'none' : 'block'; };
  document.addEventListener('click', (e) => { if (!ovHelp.contains(e.target) && e.target !== ovHelpBtn) ovHelp.style.display = 'none'; });
  ovConnect.onclick  = ()=>{ if (!ovUrl.value || !ovUsd.value) return alert("Fill URL and USD path"); ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({action:'connect', url:ovUrl.value, usd:ovUsd.value })); logOv("Requested connection"); } else logOv("Connecting‚Ä¶"); };
  ovGenerate.onclick = ()=>{ ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({action:'generate', res:ovRes.value, format:ovFormat.value})); logOv("Generating map‚Ä¶"); } else logOv("Bridge not connected"); };
  ovRefresh.onclick  = ()=>{ ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({action:'last'})); logOv("Fetching last render‚Ä¶"); } };
  ovOpenLibrary.onclick = ()=>{ openRenders(); ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({action:'list'})); logOv("Listing renders‚Ä¶"); } };

  /* Previous renders modal */
  function openRenders(){ rendersModal.style.display='flex'; }
  function closeRenders(){ rendersModal.style.display='none'; }
  openRendersBtn.onclick = ()=>{ openRenders(); ensureWS(); if (ws?.readyState===WebSocket.OPEN) ws.send(JSON.stringify({ action:'list' })); };
  rendersClose.onclick   = closeRenders;
  rendersModal.addEventListener('click', (e)=>{ if (e.target===rendersModal) closeRenders(); });

  function buildLibrary(items){
    rlGrid.innerHTML = '';
    if (!items.length){
      rlGrid.innerHTML = '<div class="sub">No renders found. Click ‚ÄúGenerate Map‚Äù first.</div>';
      return;
    }
    items.sort((a,b)=>(b.mtime||'').localeCompare(a.mtime||''));
    items.forEach(it=>{
      const card = document.createElement('div');
      card.className = 'rl-card';
      const thumb = it.thumb || '';
      const when  = it.mtime ? new Date(it.mtime).toLocaleString() : '';
      card.innerHTML = `
        <div class="rl-shot" style="background-image:url('${thumb}')"></div>
        <div class="rl-meta">
          <div style="color:#fff">${it.name || 'Render'}</div>
          <div style="color:#c9b27a">${when}</div>
        </div>
        <div class="rl-actions">
          <button class="btn" data-act="load">Load</button>
          <button class="btn" data-act="copy">Copy Name</button>
        </div>`;
      card.querySelector('[data-act="load"]').onclick = ()=>{ ensureWS(); if (ws?.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({ action:'get', name: it.name })); logOv('Loading ' + it.name); closeRenders(); } };
      card.querySelector('[data-act="copy"]').onclick = ()=>{ navigator.clipboard.writeText(it.name).then(()=>logOv('Name copied.')); };
      rlGrid.appendChild(card);
    });
  }

  /* ===== Unified Pointer Interactions to prevent "crazy" buttons ===== */
  function startPan(e){
    action = { type:'pan', startX:e.clientX, startY:e.clientY, ox:offset.x, oy:offset.y };
    wrap.style.cursor = 'grabbing';
  }
  function updatePan(e){
    const dx = e.clientX - action.startX;
    const dy = e.clientY - action.startY;
    offset.x = action.ox + dx;
    offset.y = action.oy + dy;
    drawWalls();
    drawTemplates();
    drawFogToScreen();
    repositionAll();
  }
  function endPan(){ wrap.style.cursor = currentTool==='pan' ? 'grab' : 'crosshair'; }

  function startDraw(e){
    const pt = pointerToWrap(e);
    const pos = screenToWorld(pt.x, pt.y);
    const sx = snap(pos.x), sy = snap(pos.y);
    if (currentTool==='ruler'){
      action = { type:'draw', draft:{type:'ruler', start:{x:sx,y:sy}, end:{x:sx,y:sy}} };
    } else if (currentTool==='circle'){
      action = { type:'draw', draft:{type:'circle', start:{x:sx,y:sy}, r:1} };
    } else if (currentTool==='cone'){
      action = { type:'draw', draft:{type:'cone', start:{x:sx,y:sy}, r:1, a0:0, a1:0} };
    } else if (currentTool==='wall'){
      if (!drawingWall) drawingWall = {points:[], type:'wall'};
      drawingWall.points.push({x:sx,y:sy});
      drawWalls();
    } else if (currentTool==='portal'){
      action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ const g=document.createElement('div'); g.className='portal'; g.style.width='1px'; g.style.height='1px'; wrap.appendChild(g); return g;})() };
      const s = worldToScreen(sx, sy);
      action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    }
  }, end:{x:sx,y:sy}} };
    } else if (currentTool==='circle'){
      action = { type:'draw', draft:{type:'circle', start:{x:sx,y:sy}, r:1} };
    } else if (currentTool==='cone'){
      action = { type:'draw', draft:{type:'cone', start:{x:sx,y:sy}, r:1, a0:0, a1:0} };
    } else if (currentTool==='wall'){
      if (!drawingWall) drawingWall = {points:[], type:'wall'};
      drawingWall.points.push({x:sx,y:sy});
      drawWalls();
    } else if (currentTool==='portal'){
      action = { type:'portal', start:{x:sx,y:sy}, ghost: (()=>{ const g=document.createElement('div'); g.className='portal'; g.style.width='1px'; g.style.height='1px'; wrap.appendChild(g); return g;})() };
      const s = worldToScreen(sx, sy);
      action.ghost.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
    }
  }
  function updateDraw(e){
    if (!action) return;
    const pt = pointerToWrap(e);
    const pos = screenToWorld(pt.x, pt.y);
    const sx = snap(pos.x), sy = snap(pos.y);
    if (action.type==='draw' && action.draft){
      if (action.draft.type==='ruler'){
        action.draft.end = {x:sx, y:sy};
      } else if (action.draft.type==='circle'){
        const dx = sx - action.draft.start.x, dy = sy - action.draft.start.y;
        action.draft.r = Math.max(1, Math.hypot(dx,dy));
      } else if (action.draft.type==='cone'){
        const dx = sx - action.draft.start.x, dy = sy - action.draft.start.y;
        const r = Math.max(1, Math.hypot(dx,dy));
        const ang = Math.atan2(dy,dx);
        const spread = Math.PI/3;
        action.draft.r = r; action.draft.a0 = ang - spread/2; action.draft.a1 = ang + spread/2;
      }
      drawTemplates();
    } else if (action.type==='portal' && action.ghost){
      const w = sx - action.start.x; const h = sy - action.start.y;
      const gx = worldToScreen(Math.min(action.start.x, action.start.x + w), Math.min(action.start.y, action.start.y + h));
      action.ghost.style.width  = Math.abs(w) + 'px';
      action.ghost.style.height = Math.abs(h) + 'px';
      action.ghost.style.transform = `translate(${gx.x}px, ${gx.y}px) scale(${scale})`;
    }
  };
      } else if (action.draft.type==='circle'){
        const dx = sx - action.draft.start.x, dy = sy - action.draft.start.y;
        action.draft.r = Math.max(1, Math.hypot(dx,dy));
      } else if (action.draft.type==='cone'){
        const dx = sx - action.draft.start.x, dy = sy - action.draft.start.y;
        const r = Math.max(1, Math.hypot(dx,dy));
        const ang = Math.atan2(dy,dx);
        const spread = Math.PI/3;
row.querySelector('[data-act="del"]').onclick  = ()=>{
  submaps.splice(i,1);
  localStorage.setItem('warvault-submaps', JSON.stringify(submaps));
  renderSubmaps();
};
return;

  }
  function endDraw(){
    if (!action) return;
    if (action.type==='draw' && action.draft){
      templates.push(action.draft);
      action=null; drawTemplates();
    } else if (action.type==='portal' && action.ghost){
      const rect = action.ghost.getBoundingClientRect();
      action.ghost.remove();
      const wrapRect = wrap.getBoundingClientRect();
      const a = action.start;
      const b = screenToWorld(rect.right - wrapRect.left, rect.bottom - wrapRect.top);
      const x = Math.min(a.x, b.x), y = Math.min(a.y, b.y);
      const w = Math.max(1, Math.abs(b.x - a.x));
      const h = Math.max(1, Math.abs(b.y - a.y));
      const newP = makePortal(x,y,w,h,null);
      promptAssignPortal(newP);
      action=null;
    }
  } else if (action.type==='portal' && action.ghost){
      const rect = action.ghost.getBoundingClientRect();
      action.ghost.remove();
      const wrapRect = wrap.getBoundingClientRect();
      const a = action.start;
      const b = screenToWorld(rect.right - wrapRect.left, rect.bottom - wrapRect.top);
      const x = Math.min(a.x, b.x), y = Math.min(a.y, b.y);
      const w = Math.max(1, Math.abs(b.x - a.x));
      const h = Math.max(1, Math.abs(b.y - a.y));
      makePortal(x,y,w,h,null);
      action=null;
    }
  }

  function startTokenDrag(token, e){
    action = { type:'token', token, sx:e.clientX, sy:e.clientY, startX:token.x, startY:token.y };
  }
  function updateTokenDrag(e){
    const tok = action.token;
    const dx = (e.clientX - action.sx)/scale;
    const dy = (e.clientY - action.sy)/scale;
    const prop = { x: snap(action.startX+dx), y: snap(action.startY+dy) };
    if (moveBlocked({x:action.startX,y:action.startY}, prop)) return;
    tok.x = prop.x; tok.y = prop.y;
    const s = worldToScreen(tok.x,tok.y);
    tok.el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
  }

  // Unified pointer handlers for the map container
  wrap.addEventListener('pointerdown', (e)=>{
    // Ignore right/middle in main flow; contextmenu handles right
    if (e.button !== 0) return;
    const targetToken = e.target.closest('.token');
    if (currentTool==='select' && targetToken){
      selectedToken = tokens.find(t=>t.el===targetToken) || null;
      if (selectedToken){ startTokenDrag(selectedToken, e); wrap.setPointerCapture?.(e.pointerId); e.preventDefault(); }
      return;
    }
    if (currentTool==='pan') { startPan(e); wrap.setPointerCapture?.(e.pointerId); e.preventDefault(); return; }
    startDraw(e); wrap.setPointerCapture?.(e.pointerId); e.preventDefault();
  });

  wrap.addEventListener('pointermove', (e)=>{
    if (!action) return;
    if (action.type==='pan') updatePan(e);
    else if (action.type==='draw' || action.type==='portal') updateDraw(e);
    else if (action.type==='token') updateTokenDrag(e);
  });

  wrap.addEventListener('pointerup', ()=>{
    if (!action) return;
    if (action.type==='pan') { endPan(); action=null; return; }
    if (action.type==='draw' || action.type==='portal') { endDraw(); return; }
    if (action.type==='token') { action=null; return; }
  });

  // Finish wall drawing via keyboard (unchanged)
  document.addEventListener('keydown', (e)=>{
    if (currentTool!=='wall') return;
    if (e.key==='Escape'){ drawingWall=null; drawWalls(); }
    if (e.key==='Enter' && drawingWall?.points?.length>1){
      for(let i=1;i<drawingWall.points.length;i++){
        walls.push({ a:drawingWall.points[i-1], b:drawingWall.points[i], type:'wall', open:false });
      }
      drawingWall=null; drawWalls();
    }
  });

  /* Init */
  resetFogWorld();
  fitCanvases();
  setTool('pan');
};
</script>
</body>
</html>
