<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The War Vault ‚Äî Battlemap</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Great+Vibes&display=swap" rel="stylesheet">
  <style>
    :root{
      --gold:#e6c57f;--accent:#b88c5c;--ink:#eee;--panel:#14131a;--mist:rgba(0,0,0,.55);--rune:rgba(230,197,127,.28);
      --paper:#f4ecd7;--paperEdge:#c9b27a;
    }
    *{box-sizing:border-box}
    body{
      margin:0;height:100vh;display:flex;flex-direction:column;background:#000;color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",sans-serif;overflow:hidden
    }

    header{
      display:flex;align-items:center;justify-content:space-between;padding:.6rem 1rem;
      border-bottom:1px solid var(--accent);background:rgba(10,10,14,.9);backdrop-filter:blur(6px);
      position:relative;z-index:20
    }
    .brand{display:flex;flex-direction:column}
    .brand .title{
      font-family:'Cinzel',serif;font-weight:900;letter-spacing:.06em;color:var(--gold);
      text-shadow:0 0 12px rgba(230,197,127,.35);font-size:1.4rem
    }
    .brand .byline{font-family:'Great Vibes',cursive;font-size:1.5rem;line-height:1;color:var(--gold)}
    .actions{display:flex;gap:.5rem;align-items:center}
    .btn{
      background:rgba(35,35,45,.85);border:1px solid var(--accent);color:var(--ink);
      padding:.35rem .6rem;border-radius:8px;cursor:pointer
    }
    .btn:hover{background:var(--accent);color:#000;box-shadow:0 0 14px rgba(230,197,127,.35)}
    .btn.toggled{background:var(--accent);color:#000}
    input,select{
      background:#1c1b24;border:1px solid var(--accent);color:var(--ink);
      padding:.35rem;border-radius:6px;width:100%
    }

    #stage{flex:1;display:grid;grid-template-columns:320px 1fr 360px;min-height:0}
    #left-panel{
      background:var(--panel);border-right:1px solid var(--accent);overflow:auto;display:flex;flex-direction:column
    }
    #right-panel{
      background:var(--panel);border-left:1px solid var(--accent);overflow:auto
    }
    #map-container{position:relative;overflow:hidden;background:#111}

    .section{padding:12px;border-bottom:1px solid rgba(255,255,255,.08)}
    .section h3{
      margin:.1rem 0 .6rem;font-family:'Cinzel',serif;color:var(--gold);font-size:1rem
    }
    .row{display:flex;gap:.5rem;align-items:center;margin:.4rem 0}
    .row.stacked{flex-direction:column;align-items:stretch}

    #map{
      position:absolute;inset:0;object-fit:contain;width:100%;height:100%;
      transform-origin:top left;cursor:grab;z-index:1
    }
    canvas{position:absolute;left:0;top:0;pointer-events:none}
    #grid-layer{z-index:2}
    #template-layer{z-index:3}
    #fog-layer{z-index:5}

    .token{
      position:absolute;border-radius:50%;background:#f44;color:#000;font-weight:800;
      display:flex;align-items:center;justify-content:center;user-select:none;cursor:grab;
      z-index:6;border:2px solid #fff;transform-origin:center;overflow:hidden
    }
    .token span{pointer-events:none}
    .token.has-img{background-size:cover;background-position:center;color:#fff;text-shadow:0 1px 2px #000}
    .portal{
      position:absolute;width:26px;height:26px;border-radius:50%;background:radial-gradient(circle at 30% 30%, #8df,#15a);
      border:2px solid #fff;box-shadow:0 0 10px #8df;z-index:7;cursor:pointer;transform-origin:center
    }

    #ctx{
      position:absolute;z-index:50;background:#1b1a22;border:1px solid var(--accent);
      border-radius:8px;overflow:hidden;display:none;min-width:180px
    }
    #ctx button{display:block;width:100%;text-align:left;padding:.5rem .7rem;background:transparent;color:var(--ink);border:none;cursor:pointer}
    #ctx button:hover{background:rgba(255,255,255,.08)}

    #submap-overlay{
      position:absolute;inset:0;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);display:none;z-index:30
    }
    .parchment{
      position:absolute;inset:6% 10%;background:var(--paper) url('https://i.imgur.com/2mJvRjF.png') center/cover no-repeat;
      box-shadow:0 20px 60px rgba(0,0,0,.6);border:2px solid var(--paperEdge);border-radius:14px;overflow:hidden
    }
    .parchment .head{
      display:flex;justify-content:space-between;align-items:center;padding:.4rem .6rem;
      background:linear-gradient(#f6eed9,#eadfbf);border-bottom:1px solid var(--paperEdge)
    }
    .parchment .head .ttl{font-family:'Cinzel',serif;color:#5a4829}
    .parchment .head .x{background:#7a1;color:#fff;border:none;padding:.3rem .55rem;border-radius:999px;cursor:pointer}
    .parchment .body{position:absolute;inset:42px 8px 8px 8px;background:#d7ccb0}

    #submap-canvas{position:absolute;inset:0}

    #token-forge{flex:1;overflow:auto}
    #forge-grid{display:grid;grid-template-columns:1fr;gap:.6rem}
    #saved-maps{
      max-height:160px;overflow:auto;border:1px solid rgba(255,255,255,.12);
      border-radius:8px;padding:.35rem
    }
    .map-item{display:flex;align-items:center;gap:.5rem;margin:.3rem 0}
    .thumb{width:42px;height:42px;background:#222;border:1px solid rgba(255,255,255,.12);background-size:cover;background-position:center;border-radius:6px}
    #initiative{margin-top:auto}

    .handle{position:absolute;width:10px;height:10px;border:2px solid #00c8ff;background:#00131a;border-radius:2px;z-index:9;pointer-events:auto}

    .ov-box{border:1px solid var(--paperEdge);border-radius:10px;background:rgba(235,220,185,.07);padding:.6rem}
    .ov-row{display:grid;grid-template-columns:100px 1fr;gap:.5rem;align-items:center;margin:.35rem 0}
    #ov-console{
      min-height:70px;max-height:160px;overflow:auto;background:#0e0d12;border:1px dashed var(--accent);
      padding:.5rem;border-radius:8px;font-family:ui-monospace,SFMono-Regular,Consolas,Menlo,monospace;font-size:.85rem
    }

    @media (max-width:1180px){
      #stage{grid-template-columns:0 1fr 360px}
      #left-panel{display:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="title">The War Vault</div>
      <div class="byline">Chris Marshall</div>
    </div>
    <div class="actions">
      <button id="btn-zoom-in" class="btn" title="Zoom in">Ôºã</button>
      <button id="btn-zoom-out" class="btn" title="Zoom out">Ôºç</button>
      <input id="map-upload" type="file" accept="image/*" class="btn" title="Upload map" />
      <button id="btn-save-map" class="btn" title="Save map">üíæ Save Map</button>
    </div>
  </header>

  <div id="stage">
    <aside id="left-panel">
      <div class="section" id="token-forge">
        <h3>Token Forge</h3>
        <div id="forge-grid">
          <div>
            <div class="row"><input id="tf-name" placeholder="Name" /></div>
            <div class="row"><label>Color</label><input id="tf-color" type="color" value="#ff4444" /></div>
            <div class="row"><label>Size (px)</label><input id="tf-size" type="number" min="24" max="120" value="42" /></div>
            <div class="row"><input id="tf-photo" type="file" accept="image/*" /></div>
            <div class="row"><button id="btn-create-token" class="btn" style="width:100%">‚ûï Create Token</button></div>
          </div>
          <div>
            <div style="margin-bottom:.3rem;color:#cbb27d">Saved Maps</div>
            <div id="saved-maps"></div>
          </div>
        </div>
      </div>

      <div class="section" id="initiative">
        <h3>Initiative</h3>
        <div class="row">
          <input id="init-name" placeholder="Name">
          <input id="init-roll" type="number" placeholder="Roll" style="max-width:90px">
        </div>
        <div class="row">
          <button id="btn-init-add" class="btn" style="width:100%">Add</button>
        </div>
        <div class="row" style="gap:.5rem">
          <button id="btn-init-next" class="btn" style="flex:1">Next</button>
          <button id="btn-init-reset" class="btn" style="flex:1">Reset</button>
        </div>
        <div id="init-list" style="margin-top:.5rem"></div>
      </div>
    </aside>

    <main id="map-container">
      <img id="map" src="https://i.imgur.com/8V7V3sP.jpg" alt="Map" />
      <canvas id="grid-layer"></canvas>
      <canvas id="template-layer"></canvas>
      <canvas id="fog-layer"></canvas>

      <div id="ctx">
        <button data-act="sheet">View Character Sheet</button>
        <button data-act="assign-submap">Assign Submap‚Ä¶</button>
        <button data-act="open-submap">Open Submap</button>
        <button data-act="delete">Delete Token</button>
      </div>

      <div id="submap-overlay">
        <div class="parchment">
          <div class="head">
            <div class="ttl" id="submap-title">Submap</div>
            <button class="x" id="close-submap">‚úï</button>
          </div>
          <div class="body">
            <canvas id="submap-canvas"></canvas>
          </div>
        </div>
      </div>
    </main>

    <aside id="right-panel">
      <div class="section">
        <h3>Tools</h3>
        <div class="row" style="flex-wrap:wrap">
          <button class="btn tool" data-tool="pan">üñêÔ∏è Pan</button>
          <button class="btn tool" data-tool="select">üñ±Ô∏è Select</button>
          <button class="btn tool" data-tool="ruler">üìè Ruler</button>
          <button class="btn tool" data-tool="los">üéØ LOS</button>
          <button class="btn tool" data-tool="circle">‚≠ï Circle</button>
          <button class="btn tool" data-tool="rect">‚ñ≠ Rect</button>
          <button class="btn tool" data-tool="cone">üî∫ Cone</button>
          <button class="btn tool" data-tool="portal">üåÄ Portal</button>
        </div>
        <div class="row">
          <button id="btn-clear-templates" class="btn" style="flex:1">Clear Templates</button>
          <label style="display:flex;align-items:center;gap:.35rem"><input type="checkbox" id="snap" /> Snap-to-grid</label>
        </div>
        <div class="row">
          <select id="fog-mode">
            <option value="none">Fog: off</option>
            <option value="reveal">Fog: reveal</option>
            <option value="hide">Fog: hide</option>
          </select>
          <select id="brush">
            <option value="20">Brush 20</option>
            <option value="40" selected>Brush 40</option>
            <option value="80">Brush 80</option>
          </select>
        </div>
        <div class="row" style="gap:.5rem">
          <button id="btn-fog-undo" class="btn" style="flex:1">‚ü≤ Fog Undo</button>
          <button id="btn-fog-redo" class="btn" style="flex:1">‚ü≥ Fog Redo</button>
        </div>
      </div>

      <div class="section" id="submap-manager">
        <h3>Submap Manager</h3>
        <div class="row"><input type="file" id="submap-file" accept="image/*"></div>
        <div class="row"><input type="text" id="submap-name" placeholder="Name"></div>
        <div class="row"><button id="btn-add-submap" class="btn" style="width:100%">‚ûï Add Submap</button></div>
        <div id="submap-list"></div>
      </div>

      <div class="section" id="omniverse-lab">
        <h3>Omniverse Lab (beta)</h3>
        <div class="ov-box">
          <div class="ov-row">
            <label for="ov-url">Nucleus URL</label>
            <input id="ov-url" placeholder="omniverse://server/Projects/WarVault" />
          </div>
          <div class="ov-row">
            <label for="ov-usd">USD Path</label>
            <input id="ov-usd" placeholder="/Scenes/Dungeon.usd" />
          </div>
          <div class="ov-row">
            <label for="ov-res">Resolution</label>
            <input id="ov-res" placeholder="4096x3072" />
          </div>
          <div class="ov-row">
            <label for="ov-format">Format</label>
            <select id="ov-format">
              <option value="webp" selected>WebP</option>
              <option value="png">PNG</option>
            </select>
          </div>
          <div class="row" style="gap:.5rem;flex-wrap:wrap">
            <button id="ov-connect" class="btn">üîó Connect</button>
            <button id="ov-generate" class="btn">‚ú® Generate Map</button>
            <button id="ov-refresh" class="btn">‚Üª Refresh</button>
            <button id="ov-open-library" class="btn">üìÇ Open Library</button>
          </div>
          <div id="ov-console" aria-live="polite">Omniverse console ready.</div>
        </div>
      </div>
    </aside>
  </div>

  <script>
    window.onload = function () {
      /* Element refs */
      const wrap = document.getElementById('map-container');
      const mapEl = document.getElementById('map');
      const grid = document.getElementById('grid-layer');
      const tpl = document.getElementById('template-layer');
      const fog = document.getElementById('fog-layer');
      const gctx = grid.getContext('2d');
      const tctx = tpl.getContext('2d');
      const fctx = fog.getContext('2d');

      const zoomInBtn = document.getElementById('btn-zoom-in');
      const zoomOutBtn = document.getElementById('btn-zoom-out');
      const mapUpload = document.getElementById('map-upload');
      const saveMapBtn = document.getElementById('btn-save-map');

      const toolButtons = Array.from(document.querySelectorAll('.tool'));
      const snapChk = document.getElementById('snap');
      const fogModeSel = document.getElementById('fog-mode');
      const brushSel = document.getElementById('brush');
      const clearTplBtn = document.getElementById('btn-clear-templates');
      const fogUndoBtn = document.getElementById('btn-fog-undo');
      const fogRedoBtn = document.getElementById('btn-fog-redo');

      const ctxMenu = document.getElementById('ctx');

      const tfName = document.getElementById('tf-name');
      const tfColor = document.getElementById('tf-color');
      const tfSize = document.getElementById('tf-size');
      const tfPhoto = document.getElementById('tf-photo');
      const createTokenBtn = document.getElementById('btn-create-token');
      const savedMapsDiv = document.getElementById('saved-maps');

      const subFile = document.getElementById('submap-file');
      const subName = document.getElementById('submap-name');
      const subAddBtn = document.getElementById('btn-add-submap');
      const subList = document.getElementById('submap-list');

      const initName = document.getElementById('init-name');
      const initRoll = document.getElementById('init-roll');
      const initAdd = document.getElementById('btn-init-add');
      const initNext = document.getElementById('btn-init-next');
      const initReset = document.getElementById('btn-init-reset');
      const initList = document.getElementById('init-list');

      /* Global state */
      let scale = 1;
      let offset = { x: 0, y: 0 };
      const cell = 50;

      let tokens = [];
      let portals = [];
      let templates = [];
      let selectedTemplate = null;

      let submaps = JSON.parse(localStorage.getItem('warvault-submaps') || '[]');
      let savedMaps = JSON.parse(localStorage.getItem('warvault-maps') || '[]');

      let currentTool = 'pan';
      let drawing = null;
      let isPanning = false;
      let panStart = { x: 0, y: 0 };
      let selectedToken = null;

      const FOG_LIMIT = 15;
      let fogUndoStack = [];
      let fogRedoStack = [];
      let paintingFog = false;
      let beganStroke = false;

      let draggingTemplate = null;
      let dragTemplateOffset = { x: 0, y: 0 };

      /* Initiative */
      let initiative = [];
      let initIdx = -1;

      /* Canvas sizing & initial draw */
      function fitCanvases() {
        const r = wrap.getBoundingClientRect();
        [grid, tpl, fog].forEach(cv => {
          cv.width = r.width;
          cv.height = r.height;
        });
        drawGrid();
        redrawTemplates();
        if (!fogUndoStack.length) {
          fctx.clearRect(0, 0, fog.width, fog.height);
          pushFogState();
        }
        repositionAll();
      }
      window.addEventListener('resize', fitCanvases);
      fitCanvases();

      /* Coordinates & helpers */
      function screenToWorld(sx, sy) {
        return { x: (sx - offset.x) / scale, y: (sy - offset.y) / scale };
      }
      function worldToScreen(wx, wy) {
        return { x: offset.x + wx * scale, y: offset.y + wy * scale };
      }
      function snap(v) {
        return snapChk.checked ? Math.round(v / cell) * cell : v;
      }

      /* Grid */
      function drawGrid() {
        const step = cell * scale;
        gctx.clearRect(0, 0, grid.width, grid.height);
        gctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--rune');
        gctx.lineWidth = 1;

        for (let x = (offset.x % step + step) % step; x < grid.width; x += step) {
          gctx.beginPath(); gctx.moveTo(x, 0); gctx.lineTo(x, grid.height); gctx.stroke();
        }
        for (let y = (offset.y % step + step) % step; y < grid.height; y += step) {
          gctx.beginPath(); gctx.moveTo(0, y); gctx.lineTo(grid.width, y); gctx.stroke();
        }
      }

      /* Reposition map & overlays */
      function repositionAll() {
        mapEl.style.transform = `translate(${offset.x}px, ${offset.y}px) scale(${scale})`;
        drawGrid();
        tokens.forEach(t => {
          const s = worldToScreen(t.x, t.y);
          t.el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
        });
        portals.forEach(p => {
          const s = worldToScreen(p.x, p.y);
          p.el.style.transform = `translate(${s.x - 13}px, ${s.y - 13}px) scale(${scale})`;
        });
        redrawTemplates();
      }

      /* Zoom / Pan */
      function setScale(newScale, anchorX, anchorY) {
        const old = scale;
        scale = Math.max(0.2, Math.min(6, newScale));
        const ax = anchorX ?? grid.width / 2;
        const ay = anchorY ?? grid.height / 2;
        const wx = (ax - offset.x) / old;
        const wy = (ay - offset.y) / old;
        offset.x = ax - wx * scale;
        offset.y = ay - wy * scale;
        repositionAll();
      }
      zoomInBtn.addEventListener('click', () => setScale(scale * 1.2));
      zoomOutBtn.addEventListener('click', () => setScale(scale / 1.2));
      wrap.addEventListener('wheel', e => {
        e.preventDefault();
        setScale(scale * (e.deltaY < 0 ? 1.15 : 0.87), e.offsetX, e.offsetY);
      }, { passive: false });

      /* Map upload */
      mapUpload.addEventListener('change', e => {
        const file = e.target.files?.[0];
        if (!file) return;
        const r = new FileReader();
        r.onload = ev => {
          mapEl.onload = () => fitCanvases();
          mapEl.src = ev.target.result;
        };
        r.readAsDataURL(file);
      });

      /* Tools */
      function setTool(t) {
        currentTool = t;
        toolButtons.forEach(b => b.classList.toggle('toggled', b.dataset.tool === t));
        fog.style.pointerEvents = fogModeSel.value !== 'none' ? 'auto' : 'none';
      }
      toolButtons.forEach(b => b.addEventListener('click', () => setTool(b.dataset.tool)));
      setTool('pan');

      /* Drawing + Fog */
      wrap.addEventListener('mousedown', e => {
        const onMap = [wrap, mapEl, grid, tpl, fog].includes(e.target);
        if (!onMap) return;

        const fogMode = fogModeSel.value;
        const w = screenToWorld(e.offsetX, e.offsetY);

        if (fogMode !== 'none') {
          beginFogStroke();
          paintFog(e.offsetX, e.offsetY, fogMode === 'reveal');
          return;
        }

        if (currentTool === 'pan') {
          isPanning = true;
          panStart = { x: e.clientX - offset.x, y: e.clientY - offset.y };
          return;
        }

        if (['ruler', 'los', 'circle', 'rect', 'cone'].includes(currentTool)) {
          const sx = snap(w.x), sy = snap(w.y);
          drawing = { type: currentTool, start: { x: sx, y: sy }, cur: { x: sx, y: sy } };
          drawTemplatePreview();
          return;
        }

        if (currentTool === 'portal') {
          const p = createPortal(snap(w.x), snap(w.y));
          const s = worldToScreen(p.x, p.y);
          p.el.style.transform = `translate(${s.x - 13}px, ${s.y - 13}px) scale(${scale})`;
          return;
        }

        if (currentTool === 'select') {
          selectedTemplate = hitTestTemplates(w.x, w.y);
          if (selectedTemplate) startDragTemplate(w.x, w.y);
          redrawTemplates();
        }
      });

      window.addEventListener('mousemove', e => {
        if (isPanning) {
          offset.x = e.clientX - panStart.x;
          offset.y = e.clientY - panStart.y;
          repositionAll();
          return;
        }
        if (paintingFog) {
          paintFog(e.offsetX, e.offsetY, fogModeSel.value === 'reveal');
          return;
        }
        if (drawing) {
          const w = screenToWorld(e.offsetX, e.offsetY);
          drawing.cur = { x: snap(w.x), y: snap(w.y) };
          drawTemplatePreview();
        }
        if (draggingTemplate) {
          const w = screenToWorld(e.offsetX, e.offsetY);
          moveTemplateTo(w.x, w.y);
        }
      });

      window.addEventListener('mouseup', () => {
        isPanning = false;
        if (paintingFog) endFogStroke();
        if (draggingTemplate) draggingTemplate = null;
        if (drawing) finalizeTemplate();
        drawing = null;
      });

      /* Fog paint + undo/redo */
      function pushFogState() {
        try {
          const img = fctx.getImageData(0, 0, fog.width, fog.height);
          fogUndoStack.push(img);
          if (fogUndoStack.length > FOG_LIMIT) fogUndoStack.shift();
          fogRedoStack = [];
        } catch (e) {}
      }
      function beginFogStroke() {
        paintingFog = true;
        beganStroke = false;
      }
      function endFogStroke() {
        paintingFog = false;
        pushFogState();
      }
      function paintFog(sx, sy, reveal) {
        if (!beganStroke) {
          pushFogState();
          beganStroke = true;
        }
        fctx.globalCompositeOperation = reveal ? 'destination-out' : 'source-over';
        if (!reveal) fctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--mist');
        const r = parseInt(brushSel.value, 10);
        fctx.beginPath(); fctx.arc(sx, sy, r, 0, Math.PI * 2); fctx.fill();
        fctx.globalCompositeOperation = 'source-over';
      }
      fogUndoBtn.addEventListener('click', () => {
        if (fogUndoStack.length < 2) return;
        const prev = fogUndoStack.pop();
        fogRedoStack.push(fctx.getImageData(0, 0, fog.width, fog.height));
        fctx.putImageData(prev, 0, 0);
      });
      fogRedoBtn.addEventListener('click', () => {
        if (!fogRedoStack.length) return;
        const img = fogRedoStack.pop();
        fogUndoStack.push(fctx.getImageData(0, 0, fog.width, fog.height));
        fctx.putImageData(img, 0, 0);
      });

      /* Templates */
      function drawTemplatePreview() {
        tctx.clearRect(0, 0, tpl.width, tpl.height);
        redrawTemplates();
        if (!drawing) return;
        const s = worldToScreen(drawing.start.x, drawing.start.y);
        const c = worldToScreen(drawing.cur.x, drawing.cur.y);
        tctx.lineWidth = 2; tctx.strokeStyle = 'rgba(0,200,255,0.9)'; tctx.fillStyle = 'rgba(0,200,255,0.25)';
        if (drawing.type === 'ruler' || drawing.type === 'los') {
          tctx.beginPath(); tctx.moveTo(s.x, s.y); tctx.lineTo(c.x, c.y); tctx.stroke();
          const ft = Math.round(Math.hypot(c.x - s.x, c.y - s.y) / (cell * scale) * 5);
          tctx.fillStyle = 'rgba(0,0,0,.7)'; tctx.fillRect((s.x + c.x) / 2 - 18, (s.y + c.y) / 2 - 10, 36, 18);
          tctx.fillStyle = '#fff'; tctx.font = '12px system-ui'; tctx.textAlign = 'center'; tctx.fillText(ft + ' ft', (s.x + c.x) / 2, (s.y + c.y) / 2 + 4);
        } else if (drawing.type === 'circle') {
          const r = Math.hypot(c.x - s.x, c.y - s.y);
          tctx.beginPath(); tctx.arc(s.x, s.y, r, 0, Math.PI * 2); tctx.fill(); tctx.stroke();
        } else if (drawing.type === 'rect') {
          tctx.beginPath(); tctx.rect(s.x, s.y, c.x - s.x, c.y - s.y); tctx.fill(); tctx.stroke();
        } else if (drawing.type === 'cone') {
          const ang = Math.atan2(c.y - s.y, c.x - s.x);
          const len = Math.hypot(c.x - s.x, c.y - s.y);
          tctx.beginPath(); tctx.moveTo(s.x, s.y); tctx.lineTo(s.x + Math.cos(ang - Math.PI / 6) * len, s.y + Math.sin(ang - Math.PI / 6) * len);
          tctx.arc(s.x, s.y, len, ang - Math.PI / 6, ang + Math.PI / 6); tctx.closePath(); tctx.fill(); tctx.stroke();
        }
      }
      function finalizeTemplate() {
        if (!drawing) return;
        const tp = { id: Date.now().toString(36), type: drawing.type, x: drawing.start.x, y: drawing.start.y };
        if (drawing.type === 'circle') tp.r = Math.hypot(drawing.cur.x - drawing.start.x, drawing.cur.y - drawing.start.y);
        if (drawing.type === 'rect') { tp.w = drawing.cur.x - drawing.start.x; tp.h = drawing.cur.y - drawing.start.y; }
        if (drawing.type === 'cone') {
          tp.ang = Math.atan2(drawing.cur.y - drawing.start.y, drawing.cur.x - drawing.start.x);
          tp.len = Math.hypot(drawing.cur.x - drawing.start.x, drawing.cur.y - drawing.start.y);
          tp.spread = Math.PI / 3;
        }
        if (!['ruler', 'los'].includes(drawing.type)) templates.push(tp);
        selectedTemplate = tp;
        redrawTemplates();
      }
      function redrawTemplates() {
        tctx.clearRect(0, 0, tpl.width, tpl.height);
        tctx.lineWidth = 2; tctx.strokeStyle = 'rgba(0,200,255,0.9)'; tctx.fillStyle = 'rgba(0,200,255,0.25)';
        templates.forEach(tp => {
          const s = worldToScreen(tp.x, tp.y);
          if (tp.type === 'circle') {
            tctx.beginPath(); tctx.arc(s.x, s.y, tp.r * scale, 0, Math.PI * 2); tctx.fill(); tctx.stroke();
          } else if (tp.type === 'rect') {
            tctx.beginPath(); tctx.rect(s.x, s.y, tp.w * scale, tp.h * scale); tctx.fill(); tctx.stroke();
          } else if (tp.type === 'cone') {
            const len = tp.len * scale;
            tctx.beginPath(); tctx.moveTo(s.x, s.y);
            tctx.lineTo(s.x + Math.cos(tp.ang - tp.spread / 2) * len, s.y + Math.sin(tp.ang - tp.spread / 2) * len);
            tctx.arc(s.x, s.y, len, tp.ang - tp.spread / 2, tp.ang + tp.spread / 2);
            tctx.closePath(); tctx.fill(); tctx.stroke();
          }
        });
      }

      /* Select & drag template (main map) */
      function hitTestTemplates(wx, wy) {
        for (let i = templates.length - 1; i >= 0; i--) {
          const tp = templates[i];
          if (tp.type === 'circle') {
            if (Math.hypot(wx - tp.x, wy - tp.y) <= tp.r) return tp;
          } else if (tp.type === 'rect') {
            if (wx >= tp.x && wx <= tp.x + tp.w && wy >= tp.y && wy <= tp.y + tp.h) return tp;
          } else if (tp.type === 'cone') {
            const ang = Math.atan2(wy - tp.y, wx - tp.x);
            const d = Math.hypot(wx - tp.x, wy - tp.y);
            const da = Math.abs((((ang - tp.ang + Math.PI * 3) % (Math.PI * 2)) - Math.PI));
            if (da <= tp.spread / 2 && d <= tp.len) return tp;
          }
        }
        return null;
      }

      function startDragTemplate(wx, wy) {
        draggingTemplate = selectedTemplate;
        if (!draggingTemplate) return;
        dragTemplateOffset.x = wx - draggingTemplate.x;
        dragTemplateOffset.y = wy - draggingTemplate.y;
      }

      function moveTemplateTo(wx, wy) {
        if (!draggingTemplate) return;
        draggingTemplate.x = snap(wx - dragTemplateOffset.x);
        draggingTemplate.y = snap(wy - dragTemplateOffset.y);
        redrawTemplates();
      }

      /* Tokens */
      function spawnToken({ name, color, size, img, char, x, y, submapId }) {
        const el = document.createElement('div');
        el.className = 'token'; el.style.width = size + 'px'; el.style.height = size + 'px'; el.style.backgroundColor = color;
        const label = document.createElement('span'); label.textContent = name.slice(0, 3).toUpperCase(); el.appendChild(label);
        if (img) { el.classList.add('has-img'); el.style.backgroundImage = `url(${img})`; }
        wrap.appendChild(el);

        const center = screenToWorld(grid.width / 2, grid.height / 2);
        const t = { el, x: x ?? snap(center.x), y: y ?? snap(center.y), size, color, img, name, char, submapId: submapId || null };
        tokens.push(t); positionToken(t);

        el.addEventListener('click', () => { openQuickSheet(t); });
        el.addEventListener('contextmenu', e => { e.preventDefault(); selectedToken = t; openCtx(e.clientX, e.clientY); });

        let dragging = false; let dOff = { x: 0, y: 0 };
        el.addEventListener('mousedown', e => { if (e.button !== 0) return; dragging = true; const s = worldToScreen(t.x, t.y); dOff.x = s.x - e.clientX; dOff.y = s.y - e.clientY; document.body.style.userSelect = 'none'; });
        window.addEventListener('mousemove', e => { if (!dragging) return; const wx = (e.clientX + dOff.x - offset.x) / scale; const wy = (e.clientY + dOff.y - offset.y) / scale; t.x = snap(wx); t.y = snap(wy); positionToken(t); });
        window.addEventListener('mouseup', () => { dragging = false; document.body.style.userSelect = ''; });

        return t;
      }
      function positionToken(t) {
        const s = worldToScreen(t.x, t.y);
        t.el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${scale})`;
      }
      function openQuickSheet(t) { alert(`${t.name}\n\n(Placeholder: Character sheet panel can render here)`); }

      /* Context menu */
      function openCtx(x, y) { ctxMenu.style.display = 'block'; ctxMenu.style.left = x + 'px'; ctxMenu.style.top = y + 'px'; }
      window.addEventListener('click', e => { if (!ctxMenu.contains(e.target)) ctxMenu.style.display = 'none'; });
      ctxMenu.addEventListener('click', e => {
        const act = e.target.dataset.act;
        if (!act || !selectedToken) return;
        if (act === 'sheet') openQuickSheet(selectedToken);
        if (act === 'assign-submap') assignSubmapToToken(selectedToken);
        if (act === 'open-submap') selectedToken.submapId ? openSubmapById(selectedToken.submapId) : alert('No submap assigned.');
        if (act === 'delete') { selectedToken.el.remove(); tokens = tokens.filter(t => t !== selectedToken); }
        ctxMenu.style.display = 'none';
      });

      /* Portals */
      function createPortal(x, y) {
        const el = document.createElement('div'); el.className = 'portal'; wrap.appendChild(el);
        const p = { el, x, y, submapId: null };
        portals.push(p);
        el.addEventListener('click', () => p.submapId ? openSubmapById(p.submapId) : assignSubmapToPortal(p));
        el.addEventListener('contextmenu', ev => { ev.preventDefault(); assignSubmapToPortal(p); });
        return p;
      }
      function assignSubmapToToken(t) {
        if (!submaps.length) return alert('Add submaps in Submap Manager.');
        const name = prompt('Type submap name:\n' + submaps.map(s => '- ' + s.name).join('\n'));
        const f = submaps.find(s => s.name.toLowerCase() === name?.toLowerCase());
        if (f) { t.submapId = f.id; alert('Assigned ' + f.name); }
      }
      function assignSubmapToPortal(p) {
        if (!submaps.length) return alert('Add submaps in Submap Manager.');
        const name = prompt('Type submap name:\n' + submaps.map(s => '- ' + s.name).join('\n'));
        const f = submaps.find(s => s.name.toLowerCase() === name?.toLowerCase());
        if (f) { p.submapId = f.id; alert('Assigned ' + f.name); }
      }

      /* Submap Manager */
      function renderSubmapList() {
        subList.innerHTML = '';
        submaps.forEach(sm => {
          const row = document.createElement('div'); row.className = 'map-item';
          const th = document.createElement('div'); th.className = 'thumb'; th.style.backgroundImage = `url(${sm.dataURL})`;
          const nm = document.createElement('div'); nm.textContent = sm.name; nm.style.flex = '1';
          const open = document.createElement('button'); open.className = 'btn'; open.textContent = 'Open'; open.onclick = () => openSubmapById(sm.id);
          row.append(th, nm, open); subList.appendChild(row);
        });
      }
      renderSubmapList();

      subAddBtn.addEventListener('click', () => {
        const file = subFile.files?.[0]; const name = (subName.value || '').trim() || 'Submap';
        if (!file) return alert('Choose an image');
        const r = new FileReader(); r.onload = e => {
          submaps.push({ id: Date.now().toString(36), name, dataURL: e.target.result });
          localStorage.setItem('warvault-submaps', JSON.stringify(submaps));
          subFile.value = ''; subName.value = ''; renderSubmapList();
        }; r.readAsDataURL(file);
      });

      /* Saved Maps */
      function renderSavedMaps() {
        savedMapsDiv.innerHTML = '';
        savedMaps.forEach((m, idx) => {
          const row = document.createElement('div'); row.className = 'map-item';
          const th = document.createElement('div'); th.className = 'thumb'; th.style.backgroundImage = `url(${m.thumbnail})`;
          const nm = document.createElement('div'); nm.textContent = m.name; nm.style.flex = '1';
          const load = document.createElement('button'); load.className = 'btn'; load.textContent = 'Load'; load.onclick = () => loadMap(idx);
          const del = document.createElement('button'); del.className = 'btn'; del.textContent = '‚úï'; del.onclick = () => { savedMaps.splice(idx, 1); localStorage.setItem('warvault-maps', JSON.stringify(savedMaps)); renderSavedMaps(); };
          row.append(th, nm, load, del); savedMapsDiv.appendChild(row);
        });
      }
      renderSavedMaps();

      saveMapBtn.addEventListener('click', () => {
        const thumb = document.createElement('canvas'); thumb.width = 220; thumb.height = 140; const cx = thumb.getContext('2d');
        const img = new Image(); img.onload = () => {
          const ar = Math.min(thumb.width / img.width, thumb.height / img.height);
          const dw = img.width * ar; const dh = img.height * ar;
          const dx = (thumb.width - dw) / 2; const dy = (thumb.height - dh) / 2;
          cx.fillStyle = '#111'; cx.fillRect(0, 0, thumb.width, thumb.height);
          cx.drawImage(img, dx, dy, dw, dh);
          const name = prompt('Name this map:', 'My Battle') || 'Untitled';
          const data = {
            name, image: mapEl.src, tokens: tokens.map(t => ({ x: t.x, y: t.y, size: t.size, color: t.color, img: t.img, name: t.name, submapId: t.submapId })),
            portals: portals.map(p => ({ x: p.x, y: p.y, submapId: p.submapId })), templates, submaps, offset, scale,
            fog: fog.toDataURL('image/png')
          };
          savedMaps.unshift({ ...data, thumbnail: thumb.toDataURL('image/png') });
          if (savedMaps.length > 30) savedMaps.pop();
          localStorage.setItem('warvault-maps', JSON.stringify(savedMaps));
          renderSavedMaps(); alert('Map saved.');
        }; img.src = mapEl.src; img.onerror = () => alert("Failed to load image for thumbnail");
      });

      function loadMap(idx) {
        const m = savedMaps[idx]; if (!m) return;
        mapEl.onload = () => fitCanvases(); mapEl.src = m.image;
        offset = m.offset || { x: 0, y: 0 }; scale = m.scale || 1;
        tokens.forEach(t => t.el.remove()); tokens = []; portals.forEach(p => p.el.remove()); portals = []; templates = m.templates || [];
        (m.tokens || []).forEach(tt => spawnToken(tt)); (m.portals || []).forEach(pp => { const p = createPortal(pp.x, pp.y); p.submapId = pp.submapId; });
        submaps = m.submaps || submaps; localStorage.setItem('warvault-submaps', JSON.stringify(submaps)); renderSubmapList();
        fctx.clearRect(0, 0, fog.width, fog.height);
        if (m.fog) { const fogImg = new Image(); fogImg.onload = () => { fctx.drawImage(fogImg, 0, 0, fog.width, fog.height); pushFogState(); }; fogImg.src = m.fog; }
        repositionAll(); alert('Map loaded.');
      }

      /* Token Forge */
      createTokenBtn.addEventListener('click', () => {
        const name = (tfName.value || '').trim() || 'Token';
        const color = tfColor.value || '#ff4444';
        const size = Math.max(24, Math.min(120, parseInt(tfSize.value || '42', 10)));
        const file = tfPhoto.files?.[0];
        if (file) { const r = new FileReader(); r.onload = e => spawnToken({ name, color, size, img: e.target.result }); r.readAsDataURL(file); }
        else { spawnToken({ name, color, size }); }
      });

      /* Initiative */
      initAdd.addEventListener('click', () => {
        const n = (initName.value || '').trim(); const r = parseInt(initRoll.value || '', 10);
        if (!n || isNaN(r)) return; initiative.push({ name: n, roll: r }); initiative.sort((a, b) => b.roll - a.roll);
        initIdx = initIdx === -1 && initiative.length ? 0 : initIdx; renderInitiative(); initName.value = ''; initRoll.value = '';
      });
      function renderInitiative() { initList.innerHTML = ''; initiative.forEach((it, i) => { const d = document.createElement('div'); d.textContent = `${i === initIdx ? '‚ñ∂ ' : ''}${it.name} ‚Äî ${it.roll}`; initList.appendChild(d); }); }
      initNext.addEventListener('click', () => { if (initiative.length) initIdx = (initIdx + 1) % initiative.length; renderInitiative(); });
      initReset.addEventListener('click', () => { initiative = []; initIdx = -1; renderInitiative(); });

      /* Submap Engine */
      const subOverlay = document.getElementById('submap-overlay');
      const subCanvas = document.getElementById('submap-canvas');
      const subTitleEl = document.getElementById('submap-title');
      const closeSub = document.getElementById('close-submap');
      const sctx = subCanvas.getContext('2d');

      let S = null;
      const submapSaves = JSON.parse(localStorage.getItem('warvault-submap-saves') || '{}');

      function saveSubmapState(id, payload) { submapSaves[id] = payload; localStorage.setItem('warvault-submap-saves', JSON.stringify(submapSaves)); }
      function getSubmapState(id) { return submapSaves[id] || null; }

      function openSubmapById(id) {
        const sm = submaps.find(s => s.id === id); if (!sm) return alert('Submap missing.');
        ensureSubToolbar();
        const body = subCanvas.parentElement; const box = body.getBoundingClientRect(); subCanvas.width = box.width; subCanvas.height = box.height;
        const last = getSubmapState(id);
        S = { id, name: sm.name, baseImage: sm.dataURL, scale: last?.scale ?? 1, offset: last?.offset ?? { x: 0, y: 0 }, cell: 50, tool: 'pan', snap: true, tokens: deepClone(last?.tokens) || [], templates: deepClone(last?.templates) || [], fogImg: null, isPanning: false, panStart: { x: 0, y: 0 }, drawing: null, draggingTemplate: null, dragOff: { x: 0, y: 0 }, paintingFog: false, beganStroke: false, undo: [], redo: [] };
        subTitleEl.textContent = S.name;
        const base = new Image(); base.onload = () => { S.base = base; if (last?.fogPNG) { const fogPic = new Image(); fogPic.onload = () => { S.fogImg = fogPic; redrawSub(); pushFogState(); }; fogPic.src = last.fogPNG; } else { clearFog(); } redrawSub(); }; base.src = S.baseImage;
        subOverlay.style.display = 'block'; closeSub.onclick = () => { subOverlay.style.display = 'none'; S = null; };
      }

      function ensureSubToolbar() {
        if (document.getElementById('sub-toolbar')) return;
        const tray = document.createElement('div'); tray.id = 'sub-toolbar'; tray.style.cssText = 'position:absolute;left:10px;top:52px;display:flex;flex-wrap:wrap;gap:6px;background:rgba(233,223,195,.9);border:1px solid #c9b27a;border-radius:8px;padding:6px;z-index:40';
        tray.innerHTML = `<button class="btn" data-sbtool="pan">üñêÔ∏è</button><button class="btn" data-sbtool="select">üñ±Ô∏è</button><button class="btn" data-sbtool="ruler">üìè</button><button class="btn" data-sbtool="circle">‚≠ï</button><button class="btn" data-sbtool="rect">‚ñ≠</button><button class="btn" data-sbtool="cone">üî∫</button><button class="btn" data-sbtool="token">üéØ</button><label style="display:flex;align-items:center;gap:4px;background:#eadfbf;padding:2px 6px;border-radius:6px;border:1px solid #c9b27a;"><span>Fog</span><select id="sb-fog-mode"><option value="none">Off</option><option value="reveal">Reveal</option><option value="hide">Hide</option></select><select id="sb-brush"><option value="20">20</option><option value="40" selected>40</option><option value="80">80</option></select></label><button id="sb-fog-undo" class="btn">‚ü≤</button><button id="sb-fog-redo" class="btn">‚ü≥</button><button id="sb-clear" class="btn">Clear</button><button id="sb-save" class="btn">üíæ Save</button><button id="sb-reset" class="btn">‚Ü∫ Reset</button>`;
        subCanvas.parentElement.appendChild(tray);
        tray.querySelectorAll('[data-sbtool]').forEach(btn => btn.addEventListener('click', () => { const t = btn.dataset.sbtool; if (S) S.tool = t; tray.querySelectorAll('[data-sbtool]').forEach(b => b.classList.toggle('toggled', b === btn)); }));
        document.getElementById('sb-fog-undo').onclick = () => subFogUndo();
        document.getElementById('sb-fog-redo').onclick = () => subFogRedo();
        document.getElementById('sb-clear').onclick = () => { if (S) S.templates = []; redrawSub(); };
        document.getElementById('sb-save').onclick = () => { if (S) saveActiveSubmap(); };
        document.getElementById('sb-reset').onclick = () => { if (S) resetToLastSave(); };
        setSubTool('pan');
      }
      function redrawSub() {
  if (!S || !S.base) return;

  // clear and parchment bg
  sctx.clearRect(0, 0, subCanvas.width, subCanvas.height);
  sctx.fillStyle = '#d7ccb0';
  sctx.fillRect(0, 0, subCanvas.width, subCanvas.height);

  // world transform
  sctx.save();
  sctx.translate(S.offset.x, S.offset.y);
  sctx.scale(S.scale, S.scale);

  // base image
  sctx.drawImage(S.base, 0, 0);

  // grid (world space, uses S.cell)
  const rune = getComputedStyle(document.documentElement).getPropertyValue('--rune');
  sctx.strokeStyle = rune;
  sctx.lineWidth = 1;
  for (let x = 0; x < S.base.width; x += S.cell) {
    sctx.beginPath(); sctx.moveTo(x, 0); sctx.lineTo(x, S.base.height); sctx.stroke();
  }
  for (let y = 0; y < S.base.height; y += S.cell) {
    sctx.beginPath(); sctx.moveTo(0, y); sctx.lineTo(S.base.width, y); sctx.stroke();
  }

  // templates
  S.templates.forEach(tp => {
    sctx.save();
    sctx.lineWidth = 2 / S.scale;
    sctx.strokeStyle = 'rgba(0,200,255,0.9)';
    sctx.fillStyle = 'rgba(0,200,255,0.25)';
    if (tp.type === 'circle') {
      sctx.beginPath(); sctx.arc(tp.x, tp.y, tp.r, 0, Math.PI * 2); sctx.fill(); sctx.stroke();
    } else if (tp.type === 'rect') {
      sctx.beginPath(); sctx.rect(tp.x, tp.y, tp.w, tp.h); sctx.fill(); sctx.stroke();
    } else if (tp.type === 'cone') {
      sctx.beginPath();
      sctx.moveTo(tp.x, tp.y);
      sctx.lineTo(tp.x + Math.cos(tp.ang - tp.spread / 2) * tp.len, tp.y + Math.sin(tp.ang - tp.spread / 2) * tp.len);
      sctx.arc(tp.x, tp.y, tp.len, tp.ang - tp.spread / 2, tp.ang + tp.spread / 2);
      sctx.closePath(); sctx.fill(); sctx.stroke();
    }
    sctx.restore();
  });

  // tokens
  S.tokens.forEach(tk => {
    sctx.save();
    sctx.lineWidth = 2 / S.scale;
    if (tk.imgData) {
      const img = new Image(); img.src = tk.imgData;
      const r = tk.size / 2;
      sctx.beginPath(); sctx.arc(tk.x, tk.y, r, 0, Math.PI * 2); sctx.closePath();
      sctx.save(); sctx.clip(); sctx.drawImage(img, tk.x - r, tk.y - r, tk.size, tk.size); sctx.restore();
      sctx.strokeStyle = '#fff'; sctx.stroke();
    } else {
      sctx.fillStyle = tk.color || '#ff4444';
      sctx.beginPath(); sctx.arc(tk.x, tk.y, tk.size / 2, 0, Math.PI * 2); sctx.fill();
      sctx.strokeStyle = '#fff'; sctx.stroke();
      sctx.fillStyle = '#000';
      sctx.font = `${Math.max(10, tk.size / 3)}px system-ui`;
      sctx.textAlign = 'center';
      sctx.textBaseline = 'middle';
      sctx.fillText((tk.name || 'TK').slice(0, 3).toUpperCase(), tk.x, tk.y);
    }
    sctx.restore();
  });

  // end world transform
  sctx.restore();

  // fog (screen space)
  if (S.fogImg) sctx.drawImage(S.fogImg, 0, 0, subCanvas.width, subCanvas.height);

  // live preview
  if (S.drawing) drawSubPreview();
}

    sctx.restore();
  });

  // end pan/zoom transform
  sctx.restore();

  // fog overlay (bitmap same size as subCanvas)
  if (S.fogImg) sctx.drawImage(S.fogImg, 0, 0, subCanvas.width, subCanvas.height);

  // preview during draw
  if (S.drawing) drawSubPreview();
}

function drawSubPreview() {
  if (!S || !S.drawing) return;
  const d = S.drawing;

  // world-space preview for shapes/ruler
  sctx.save();
  sctx.translate(S.offset.x, S.offset.y);
  sctx.scale(S.scale, S.scale);

  sctx.lineWidth = 2 / S.scale;
  sctx.strokeStyle = 'rgba(0,200,255,0.9)';
  sctx.fillStyle = 'rgba(0,200,255,0.25)';

  if (d.type === 'ruler') {
    sctx.beginPath(); sctx.moveTo(d.start.x, d.start.y); sctx.lineTo(d.cur.x, d.cur.y); sctx.stroke();
    const ft = Math.round((Math.hypot(d.cur.x - d.start.x, d.cur.y - d.start.y) / S.cell) * 5);
    sctx.restore();

    // small label in screen space for clarity
    sctx.save();
    const midX = (d.scrS.x + d.scrC.x) / 2, midY = (d.scrS.y + d.scrC.y) / 2;
    sctx.fillStyle = 'rgba(0,0,0,.7)';
    sctx.fillRect(midX - 18, midY - 10, 36, 18);
    sctx.fillStyle = '#fff';
    sctx.font = '12px system-ui';
    sctx.textAlign = 'center';
    sctx.fillText(ft + ' ft', midX, midY + 4);
    sctx.restore();
    return;
  }

  if (d.type === 'circle') {
    const r = Math.hypot(d.cur.x - d.start.x, d.cur.y - d.start.y);
    sctx.beginPath(); sctx.arc(d.start.x, d.start.y, r, 0, Math.PI * 2); sctx.fill(); sctx.stroke();
  } else if (d.type === 'rect') {
    sctx.beginPath(); sctx.rect(d.start.x, d.start.y, d.cur.x - d.start.x, d.cur.y - d.start.y); sctx.fill(); sctx.stroke();
  } else if (d.type === 'cone') {
    const ang = Math.atan2(d.cur.y - d.start.y, d.cur.x - d.start.x);
    const len = Math.hypot(d.cur.x - d.start.x, d.cur.y - d.start.y);
    const spread = Math.PI / 3;
    sctx.beginPath();
    sctx.moveTo(d.start.x, d.start.y);
    sctx.lineTo(d.start.x + Math.cos(ang - spread / 2) * len, d.start.y + Math.sin(ang - spread / 2) * len);
    sctx.arc(d.start.x, d.start.y, len, ang - spread / 2, ang + spread / 2);
    sctx.closePath(); sctx.fill(); sctx.stroke();
  }
  sctx.restore();
}

/* ===== Pointer helpers ===== */
function scr2world(sx, sy) { return { x: (sx - S.offset.x) / S.scale, y: (sy - S.offset.y) / S.scale }; }
function snapW(v) { return S.snap ? Math.round(v / S.cell) * S.cell : v; }

/* ===== Submap mouse / wheel ===== */
subCanvas.addEventListener('wheel', (e) => {
  if (!S) return;
  e.preventDefault();
  const old = S.scale;
  const ns = Math.max(.2, Math.min(6, S.scale * (e.deltaY < 0 ? 1.15 : 0.87)));
  const ax = e.offsetX, ay = e.offsetY;
  const wx = (ax - S.offset.x) / old, wy = (ay - S.offset.y) / old;
  S.scale = ns;
  S.offset.x = ax - wx * ns;
  S.offset.y = ay - wy * ns;
  redrawSub();
}, { passive: false });

subCanvas.addEventListener('mousedown', (e) => {
  if (!S) return;
  const fogMode = (document.getElementById('sb-fog-mode') || {}).value || 'none';
  const world = scr2world(e.offsetX, e.offsetY);

  if (fogMode !== 'none') {
    beginSubFogStroke();
    paintSubFog(e.offsetX, e.offsetY, fogMode === 'reveal');
    return;
  }

  if (S.tool === 'pan') {
    S.isPanning = true;
    S.panStart = { x: e.clientX - S.offset.x, y: e.clientY - S.offset.y };
    return;
  }

  if (['ruler', 'circle', 'rect', 'cone'].includes(S.tool)) {
    const sx = snapW(world.x), sy = snapW(world.y);
    S.drawing = { type: S.tool === 'ruler' ? 'ruler' : S.tool, start: { x: sx, y: sy }, cur: { x: sx, y: sy }, scrS: { x: e.offsetX, y: e.offsetY }, scrC: { x: e.offsetX, y: e.offsetY } };
    redrawSub();
    return;
  }

  if (S.tool === 'token') {
    const name = prompt('Token name?', 'Token');
    if (name === null) return;
    const size = parseInt(prompt('Size (px)?', '42') || '42', 10);
    const color = prompt('Color (hex)?', '#ff4444') || '#ff4444';
    const tk = { name, size: Math.max(24, Math.min(120, size)), color, x: snapW(world.x), y: snapW(world.y), imgData: null };
    S.tokens.push(tk);
    redrawSub();
    return;
  }

  if (S.tool === 'select') {
    const hit = subHitTemplate(world.x, world.y);
    if (hit) {
      S.draggingTemplate = hit;
      S.dragOff = { x: world.x - hit.x, y: world.y - hit.y };
    }
  }
});

window.addEventListener('mousemove', (e) => {
  if (!S) return;
  if (S.isPanning) {
    S.offset.x = e.clientX - S.panStart.x;
    S.offset.y = e.clientY - S.panStart.y;
    redrawSub();
    return;
  }
  const fogMode = (document.getElementById('sb-fog-mode') || {}).value || 'none';
  if (S.paintingFog) {
    paintSubFog(e.offsetX, e.offsetY, fogMode === 'reveal');
    return;
  }
  if (S.drawing) {
    const w = scr2world(e.offsetX, e.offsetY);
    S.drawing.cur = { x: snapW(w.x), y: snapW(w.y) };
    S.drawing.scrC = { x: e.offsetX, y: e.offsetY };
    redrawSub();
  }
  if (S.draggingTemplate) {
    const w = scr2world(e.offsetX, e.offsetY);
    S.draggingTemplate.x = snapW(w.x - S.dragOff.x);
    S.draggingTemplate.y = snapW(w.y - S.dragOff.y);
    redrawSub();
  }
});

window.addEventListener('mouseup', () => {
  if (!S) return;
  if (S.isPanning) S.isPanning = false;
  if (S.paintingFog) endSubFogStroke();
  if (S.drawing) { finalizeSubTemplate(); S.drawing = null; }
  if (S.draggingTemplate) S.draggingTemplate = null;
});

/* ===== Submap template finalize / hit-test ===== */
function finalizeSubTemplate() {
  const d = S.drawing; if (!d) return;
  const tp = { type: d.type, x: d.start.x, y: d.start.y };
  if (d.type === 'circle') { tp.r = Math.hypot(d.cur.x - d.start.x, d.cur.y - d.start.y); }
  if (d.type === 'rect')   { tp.w = d.cur.x - d.start.x; tp.h = d.cur.y - d.start.y; }
  if (d.type === 'cone')   { tp.ang = Math.atan2(d.cur.y - d.start.y, d.cur.x - d.start.x); tp.len = Math.hypot(d.cur.x - d.start.x, d.cur.y - d.start.y); tp.spread = Math.PI / 3; }
  if (d.type === 'ruler') return; // transient
  S.templates.push(tp);
  redrawSub();
}
function subHitTemplate(wx, wy) {
  for (let i = S.templates.length - 1; i >= 0; i--) {
    const tp = S.templates[i];
    if (tp.type === 'circle') {
      if (Math.hypot(wx - tp.x, wy - tp.y) <= tp.r) return tp;
    } else if (tp.type === 'rect') {
      if (wx >= tp.x && wx <= tp.x + tp.w && wy >= tp.y && wy <= tp.y + tp.h) return tp;
    } else if (tp.type === 'cone') {
      const ang = Math.atan2(wy - tp.y, wx - tp.x);
      const d   = Math.hypot(wx - tp.x, wy - tp.y); // ‚úÖ correct: use tp.x
      const da  = Math.abs((((ang - tp.ang + Math.PI * 3) % (Math.PI * 2)) - Math.PI));
      if (da <= tp.spread / 2 && d <= tp.len) return tp;
    }
  }
  return null;
}

/* ===== Submap fog bitmap + undo/redo ===== */
function clearFog() {
  const fc = document.createElement('canvas');
  fc.width = subCanvas.width; fc.height = subCanvas.height;
  S.fogImg = new Image();
  S.fogImg.src = fc.toDataURL('image/png');
  pushFogState();
}
function pushFogState() {
  try {
    const snap = exportFogPNG();
    S.undo.push(snap);
    if (S.undo.length > 15) S.undo.shift();
    S.redo.length = 0;
  } catch (e) {}
}
function beginSubFogStroke() { S.paintingFog = true; S.beganStroke = false; }
function endSubFogStroke() {
  S.paintingFog = false;
  try {
    const snap = exportFogPNG();
    S.undo.push(snap);
    if (S.undo.length > 15) S.undo.shift();
    S.redo.length = 0;
  } catch (e) {}
}
function paintSubFog(sx, sy, reveal) {
  if (!S.beganStroke) { pushFogState(); S.beganStroke = true; }
  const fc = document.createElement('canvas');
  fc.width = subCanvas.width; fc.height = subCanvas.height;
  const fx = fc.getContext('2d');
  if (S.fogImg) fx.drawImage(S.fogImg, 0, 0, fc.width, fc.height);

  fx.globalCompositeOperation = reveal ? 'destination-out' : 'source-over';
  if (!reveal) fx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--mist');
  const r = parseInt((document.getElementById('sb-brush') || {}).value || '40', 10);
  fx.beginPath(); fx.arc(sx, sy, r, 0, Math.PI * 2); fx.fill();
  fx.globalCompositeOperation = 'source-over';

  S.fogImg = new Image();
  S.fogImg.src = fc.toDataURL('image/png');
  S.fogImg.onload = () => redrawSub();
}
function subFogUndo() {
  if (!S || S.undo.length < 2) return;
  const cur = S.undo.pop();
  S.redo.push(cur);
  const prev = S.undo[S.undo.length - 1];
  S.fogImg = new Image();
  S.fogImg.onload = () => redrawSub();
  S.fogImg.src = prev;
}
function subFogRedo() {
  if (!S || !S.redo.length) return;
  const img = S.redo.pop();
  S.undo.push(img);
  S.fogImg = new Image();
  S.fogImg.onload = () => redrawSub();
  S.fogImg.src = img;
}
function exportFogPNG() {
  const fc = document.createElement('canvas');
  fc.width = subCanvas.width; fc.height = subCanvas.height;
  const fx = fc.getContext('2d');
  if (S.fogImg) fx.drawImage(S.fogImg, 0, 0, fc.width, fc.height);
  return fc.toDataURL('image/png');
}

/* ===== Save / Reset for submap ===== */
function saveActiveSubmap() {
  if (!S) return;
  const payload = {
    image: S.baseImage,
    tokens: deepClone(S.tokens),
    templates: deepClone(S.templates),
    fogPNG: exportFogPNG(),
    offset: deepClone(S.offset),
    scale: S.scale
  };
  saveSubmapState(S.id, payload);
  alert('Submap saved.');
}
function resetToLastSave() {
  if (!S) return;
  const last = getSubmapState(S.id);
  if (!last) {
    S.tokens = []; S.templates = [];
    clearFog(); S.offset = { x: 0, y: 0 }; S.scale = 1;
    redrawSub();
    return;
  }
  S.tokens = deepClone(last.tokens) || [];
  S.templates = deepClone(last.templates) || [];
  S.offset = deepClone(last.offset) || { x: 0, y: 0 };
  S.scale = last.scale || 1;
  if (last.fogPNG) {
    const fogPic = new Image();
    fogPic.onload = () => { S.fogImg = fogPic; redrawSub(); pushFogState(); };
    fogPic.src = last.fogPNG;
  } else {
    clearFog();
  }
  redrawSub();
}

/* ===== Utilities ===== */
function deepClone(v) { return v ? JSON.parse(JSON.stringify(v)) : v; }

// END window.onload
};
</script>
