<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WarVault 3D – City Builder & Walkthrough</title>
<style>
  :root{
    --ink:#f1f5f9;--panel:#0f1116;--accent:#9ec1ff;--gold:#e9c46a;--danger:#ff7675;
  }
  html,body{height:100%;margin:0;background:#0b0f16;color:var(--ink);font:14px/1.25 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:fixed;inset:0;overflow:hidden}
  canvas{display:block}

  /* UI */
  .hud{position:fixed;left:12px;top:12px;display:flex;gap:12px;z-index:10;pointer-events:none}
  .panel{
    pointer-events:auto;background:rgba(15,17,22,.85);backdrop-filter:blur(8px);
    border:1px solid rgba(158,193,255,.25);box-shadow:0 10px 30px rgba(0,0,0,.35);
    border-radius:12px;padding:10px;min-width:260px
  }
  .panel h3{margin:0 0 8px;font-size:13px;letter-spacing:.06em;color:#bcd2ff;text-transform:uppercase}
  .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  .row .grow{flex:1}
  .btn{
    background:#141822;border:1px solid rgba(158,193,255,.35);color:#e9eefc;
    padding:6px 10px;border-radius:8px;cursor:pointer;font-weight:600
  }
  .btn:hover{border-color:#c9dcff;background:#1a2030}
  .btn.primary{background:#1f2a44;border-color:#9ec1ff}
  .btn.danger{border-color:#ff9aa2;color:#ffdfe1}
  .seg{display:flex;border:1px solid rgba(158,193,255,.35);border-radius:9px;overflow:hidden}
  .seg button{border:0;background:transparent;padding:6px 8px;color:#bcd2ff}
  .seg button.active{background:#1f2a44;color:#fff}
  input[type="color"]{width:40px;height:28px;border:1px solid rgba(158,193,255,.35);border-radius:6px;background:#0d1118}
  input[type="range"]{width:100%}
  input[type="text"],input[type="number"]{
    width:100%;background:#0d1118;border:1px solid rgba(158,193,255,.35);color:#e9eefc;
    border-radius:8px;padding:6px 8px
  }
  label{color:#a7b8dd;font-size:12px}
  #help{
    position:fixed;right:12px;top:12px;max-width:360px;white-space:pre-line
  }
  .kbd{display:inline-block;padding:1px 6px;border-radius:5px;border:1px solid #3c4254;background:#121723;color:#d7e3ff;font:12px ui-monospace}
  .footer{position:fixed;left:12px;bottom:10px;color:#a3b1cf}
  .link{color:#9ec1ff;cursor:pointer}
  /* outline highlight (simple emissive pop) */
  .hint{position:fixed;left:50%;top:12px;transform:translateX(-50%);background:#0d1118aa;border:1px solid #3c4254;color:#cfe3ff;padding:6px 10px;border-radius:8px}
</style>
</head>
<body>
<div id="app"></div>

<div class="hud">
  <!-- Scene / session -->
  <div class="panel" style="min-width:300px">
    <h3>Scene</h3>
    <div class="row">
      <button id="btn-walk" class="btn primary grow">Enter Walk Mode</button>
      <button id="btn-edit" class="btn grow">Edit Mode</button>
    </div>
    <div class="row">
      <button id="btn-gen" class="btn">Generate City</button>
      <button id="btn-clear" class="btn">Clear</button>
    </div>
    <div class="row">
      <button id="btn-save" class="btn">Save</button>
      <button id="btn-load" class="btn">Load</button>
      <button id="btn-export" class="btn">Export</button>
      <label class="btn" for="file-import">Import</label>
      <input id="file-import" type="file" accept="application/json" style="display:none">
    </div>
    <div class="row">
      <label><input type="checkbox" id="chk-grid" checked> Show Grid</label>
      <label><input type="checkbox" id="chk-snap" checked> Snap</label>
    </div>
  </div>

  <!-- Tools -->
  <div class="panel" style="min-width:360px">
    <h3>Tools</h3>
    <div class="row seg">
      <button data-tool="select" class="active">Select</button>
      <button data-tool="build">Build</button>
      <button data-tool="wall">Wall</button>
      <button data-tool="paint">Paint</button>
      <button data-tool="token">Token</button>
      <button data-tool="portal">Portal</button>
      <button data-tool="erase">Erase</button>
    </div>
    <div class="row">
      <div class="grow">
        <label>Height</label>
        <input id="rng-height" type="range" min="4" max="120" value="30">
      </div>
      <div style="width:40%">
        <label>Color</label>
        <input id="color" type="color" value="#6aa1ff">
      </div>
    </div>
    <div class="row">
      <input id="name" type="text" placeholder="Name / Portal tag / Token label">
    </div>
    <div class="row">
      <button id="btn-duplicate" class="btn">Duplicate</button>
      <button id="btn-delete" class="btn danger">Delete</button>
    </div>
  </div>
</div>

<div id="help" class="panel">
  <h3>Controls</h3>
  <div>
  <b>Walk</b>: <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span>,
  <span class="kbd">Shift</span> sprint, mouse to look · <span class="kbd">E</span> toggle Edit/Walk
  <br><b>Edit</b>: click to act · <span class="kbd">R</span>/<span class="kbd">F</span> height ± · <span class="kbd">G</span> snap · <span class="kbd">Del</span> delete
  <br><b>Select</b>: click object · <b>Build</b>: click ground to add building
  <br><b>Wall</b>: click start → click end · <b>Paint</b>: click object to color/height
  <br><b>Token</b>: click ground · <b>Portal</b>: drag rectangle; type shared name to link
  </div>
</div>

<div class="footer">WarVault 3D starter • no server required</div>
<div id="hint" class="hint" style="display:none"></div>

<!-- Three.js + controls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158/examples/js/controls/OrbitControls.js"></script>
<script>
(() => {
  const app = document.getElementById('app');

  // --- THREE setup ---
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  app.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0f18);
  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(60, 40, 60);

  // Lights
  const hemi = new THREE.HemisphereLight(0xdde8ff, 0x334055, 0.75);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(80,120,60);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  // Ground (roads will be drawn on a canvas texture)
  const groundSize = 2000;
  const groundCanvas = document.createElement('canvas');
  groundCanvas.width = groundCanvas.height = 2048;
  const gctx = groundCanvas.getContext('2d');
  const groundTex = new THREE.CanvasTexture(groundCanvas);
  groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping;
  groundTex.anisotropy = 8;

  const groundMat = new THREE.MeshStandardMaterial({
    map: groundTex, roughness: 1, metalness: 0, color: 0x10151f
  });
  const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  ground.name = 'GROUND';
  scene.add(ground);

  // Grid helper (toggle)
  const gridHelper = new THREE.GridHelper(1000, 100, 0x3a415a, 0x192036);
  gridHelper.position.y = 0.05;
  scene.add(gridHelper);

  // Controls
  const orbit = new THREE.OrbitControls(camera, renderer.domElement);
  orbit.enableDamping = true;
  orbit.maxPolarAngle = Math.PI*0.49;

  const fp = new THREE.PointerLockControls(camera, renderer.domElement);
  const fpObject = fp.getObject();
  scene.add(fpObject);

  // Walk physics
  const keys = {};
  let walking = false;
  let velocity = new THREE.Vector3();
  const speed = 25;
  const sprint = 1.6;
  const playerHeight = 2;  // eye height
  const playerRadius = 1;  // for simple xz collision

  // --- State ---
  let mode = 'edit'; // 'walk' | 'edit'
  let tool = 'select';
  let snap = true;
  let showGrid = true;
  const rngHeight = document.getElementById('rng-height');
  const colorInput = document.getElementById('color');
  const nameInput = document.getElementById('name');
  const hint = document.getElementById('hint');

  // Collections
  const buildings = []; // meshes, userData: {type:'building', size:{w,d,h}}
  const walls = [];     // thin boxes, userData:{type:'wall'}
  const tokens = [];    // cylinders, label sprites, userData:{type:'token', label}
  const portals = [];   // group: plane (transparent) + gold frame (lines). userData:{type:'portal', tag}
  const colliders = []; // building + walls colliders (Box3 in world)

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let hover = null, selected = null;

  // UI refs
  const $ = id => document.getElementById(id);
  const btnWalk = $('btn-walk');
  const btnEdit = $('btn-edit');
  const btnGen  = $('btn-gen');
  const btnClear= $('btn-clear');
  const btnSave = $('btn-save');
  const btnLoad = $('btn-load');
  const btnExport = $('btn-export');
  const fileImport = $('file-import');
  const chkGrid = $('chk-grid');
  const chkSnap = $('chk-snap');
  const btnDuplicate = $('btn-duplicate');
  const btnDelete    = $('btn-delete');

  // Tool buttons group
  const toolButtons = Array.from(document.querySelectorAll('[data-tool]'));
  toolButtons.forEach(b=>{
    b.addEventListener('click', ()=>{
      toolButtons.forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      tool = b.getAttribute('data-tool');
      showHint(tool);
    });
  });

  // Resize
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // --- Utility ---
  const rnd = (a,b)=>a+Math.random()*(b-a);
  const toHex = (c)=> '#'+c.toString(16).padStart(6,'0');

  function snapV3(v){
    if (!snap) return v;
    const s = 2; // grid unit meters
    v.x = Math.round(v.x/s)*s;
    v.y = Math.round(v.y/s)*s;
    v.z = Math.round(v.z/s)*s;
    return v;
  }

  function worldFromMouse(ev, targets=[ground, ...buildings, ...walls, ...portals]){
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    return raycaster.intersectObjects(targets, true);
  }

  function setSelected(obj){
    if (selected && selected.material) {
      // reset emissive if present
      if (selected.material.emissive) selected.material.emissive.setHex(selected.userData.__em||0x000000);
    }
    selected = obj;
    if (selected && selected.material){
      selected.userData.__em = selected.material.emissive?.getHex?.() ?? 0x000000;
      if (selected.material.emissive) selected.material.emissive.setHex(0x3355ff);
    }
  }

  function addColliderFromMesh(mesh){
    mesh.updateMatrixWorld(true);
    const box = new THREE.Box3().setFromObject(mesh);
    mesh.userData.collider = box;
    colliders.push(box);
  }
  function rebuildColliders(){
    colliders.length = 0;
    [...buildings, ...walls].forEach(m=> addColliderFromMesh(m));
  }

  // --- Generators ---
  function drawRoadTexture({blocksX=8, blocksZ=8, blockSize=40, road=6}){
    const c = groundCanvas, ctx = gctx;
    const W = c.width, H = c.height;
    ctx.fillStyle = '#121826'; ctx.fillRect(0,0,W,H);

    // subtle noise
    const img = ctx.createImageData(W,H);
    for (let i=0;i<img.data.length;i+=4){
      const v = 16 + Math.random()*6;
      img.data[i]=img.data[i+1]=img.data[i+2]=v; img.data[i+3]=20;
    }
    ctx.putImageData(img,0,0);

    // draw grid roads
    const totalW = blocksX*blockSize + (blocksX+1)*road;
    const totalH = blocksZ*blockSize + (blocksZ+1)*road;
    const ox = (W-totalW)/2, oz = (H-totalH)/2;

    ctx.fillStyle = '#1c2333';
    // vertical
    for (let ix=0; ix<=blocksX; ix++){
      const x = ox + ix*(blockSize+road);
      ctx.fillRect(x, oz, road, totalH);
    }
    // horizontal
    for (let iz=0; iz<=blocksZ; iz++){
      const z = oz + iz*(blockSize+road);
      ctx.fillRect(ox, z, totalW, road);
    }

    // lane markings (very subtle)
    ctx.fillStyle = 'rgba(240,240,240,.06)';
    for (let iz=0; iz<=blocksZ; iz++){
      const z = oz + iz*(blockSize+road) + road/2 - 1;
      ctx.fillRect(ox, z, totalW, 2);
    }
    for (let ix=0; ix<=blocksX; ix++){
      const x = ox + ix*(blockSize+road) + road/2 - 1;
      ctx.fillRect(x, oz, 2, totalH);
    }

    groundTex.needsUpdate = true;
  }

  function clearScene(){
    // remove meshes
    [...buildings, ...walls, ...tokens, ...portals].forEach(m=>{
      if (m.parent) m.parent.remove(m);
    });
    buildings.length = 0;
    walls.length = 0;
    tokens.length = 0;
    portals.length = 0;
    setSelected(null);
    rebuildColliders();
  }

  function generateCity(){
    clearScene();

    const params = {blocksX:8, blocksZ:8, blockSize:40, road:6};
    drawRoadTexture(params);

    const {blocksX, blocksZ, blockSize, road} = params;
    const originX = -(blocksX*blockSize + (blocksX-1)*road)/2;
    const originZ = -(blocksZ*blockSize + (blocksZ-1)*road)/2;

    for (let gx=0; gx<blocksX; gx++){
      for (let gz=0; gz<blocksZ; gz++){
        // one "block" area
        const baseX = originX + gx*(blockSize+road);
        const baseZ = originZ + gz*(blockSize+road);

        // sublots: 2x2 inside each block
        const lots = 2;
        const lotW = (blockSize - 4)/lots;
        const lotD = (blockSize - 4)/lots;

        for (let lx=0; lx<lots; lx++){
          for (let lz=0; lz<lots; lz++){
            const cx = baseX + 2 + lx*lotW + lotW/2;
            const cz = baseZ + 2 + lz*lotD + lotD/2;
            const w  = rnd(lotW*0.6, lotW*0.95);
            const d  = rnd(lotD*0.6, lotD*0.95);
            const h  = rnd(12, 80);
            const color = new THREE.Color().setHSL(rnd(0.55,0.65), rnd(0.3,0.55), rnd(0.35,0.6));
            addBuilding(new THREE.Vector3(cx, 0, cz), w, d, h, color.getHex());
          }
        }
      }
    }

    rebuildColliders();
  }

  // --- Builders (objects) ---
  function addBuilding(pos, w=20, d=20, h=30, color=0x6aa1ff){
    const geo = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.75, metalness: 0.05 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    mesh.position.y = h/2;
    mesh.castShadow = true; mesh.receiveShadow = true;
    mesh.userData.type='building';
    mesh.userData.size={w,d,h};
    scene.add(mesh);
    buildings.push(mesh);
    addColliderFromMesh(mesh);
    return mesh;
  }

  function addWall(a, b, height=6, thickness=0.5, color=0xbac8ff){
    const dir = new THREE.Vector3().subVectors(b,a);
    const len = dir.length();
    if (len < 0.001) return;
    const y = height/2;
    const geo = new THREE.BoxGeometry(len, height, thickness);
    const mat = new THREE.MeshStandardMaterial({ color, roughness:.8, metalness:0.02 });
    const wall = new THREE.Mesh(geo, mat);
    wall.position.set((a.x+b.x)/2, y, (a.z+b.z)/2);
    wall.rotation.y = Math.atan2(dir.x, dir.z); // align along xz
    wall.castShadow = true; wall.receiveShadow = true;
    wall.userData.type='wall';
    scene.add(wall);
    walls.push(wall);
    addColliderFromMesh(wall);
    return wall;
  }

  function makeLabelSprite(text){
    const c = document.createElement('canvas');
    const pad=8; c.width=256; c.height=64;
    const x = c.getContext('2d');
    x.fillStyle='rgba(10,15,22,.85)'; x.fillRect(0,0,c.width,c.height);
    x.strokeStyle='rgba(158,193,255,.45)'; x.strokeRect(0,0,c.width,c.height);
    x.font='28px system-ui,Segoe UI,Roboto'; x.fillStyle='#e9eefc';
    x.textAlign='center'; x.textBaseline='middle';
    x.fillText(text, c.width/2, c.height/2);
    const tex = new THREE.CanvasTexture(c); tex.anisotropy=8; tex.minFilter=THREE.LinearFilter;
    const mat = new THREE.SpriteMaterial({ map: tex, depthWrite:false });
    const spr = new THREE.Sprite(mat);
    spr.scale.set(8, 2, 1);
    return spr;
  }

  function addToken(pos, label='Token', color=0xffcc66){
    const geo = new THREE.CylinderGeometry(0.6, 0.6, 0.3, 24);
    const mat = new THREE.MeshStandardMaterial({ color, roughness:0.6, metalness:0.2 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos); mesh.position.y = 0.18;
    mesh.castShadow = true; mesh.receiveShadow = true;
    mesh.userData.type='token'; mesh.userData.label = label;
    const spr = makeLabelSprite(label);
    spr.position.set(0, 2.0, 0);
    mesh.add(spr);
    scene.add(mesh);
    tokens.push(mesh);
    return mesh;
  }

  function addPortalRect(a, b, tag=''){
    // build a rectangular portal aligned to world axes (drag rectangle)
    const x0 = Math.min(a.x, b.x), x1 = Math.max(a.x, b.x);
    const z0 = Math.min(a.z, b.z), z1 = Math.max(a.z, b.z);
    const w = Math.max(2, x1 - x0), h = Math.max(2, z1 - z0);
    const cx = (x0+x1)/2, cz = (z0+z1)/2;

    // Transparent face
    const planeGeo = new THREE.PlaneGeometry(w, h);
    const planeMat = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.05, depthWrite:false });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI/2; // lie on ground
    plane.position.set(cx, 0.02, cz);

    // Gold outline (frame)
    const edges = new THREE.EdgesGeometry(planeGeo);
    const lineMat = new THREE.LineBasicMaterial({ color: 0xe9c46a, linewidth: 2 });
    const frame = new THREE.LineSegments(edges, lineMat);
    frame.rotation.copy(plane.rotation);
    frame.position.copy(plane.position);
    frame.position.y = 0.03;

    const group = new THREE.Group();
    group.add(plane); group.add(frame);
    group.userData.type='portal';
    group.userData.tag = tag || '';
    scene.add(group);
    portals.push(group);
    return group;
  }

  // --- Selection & editing ---
  let wallDraft = null; // {a:Vector3}
  let portalDraft = null; // {a, ghostGroup}

  renderer.domElement.addEventListener('mousemove', (e)=>{
    if (mode!=='edit') return;
    const hit = worldFromMouse(e, [ground, ...buildings, ...walls, ...portals])[0];
    const obj = hit ? topOwner(hit.object) : null;
    if (hover !== obj){
      hover = obj;
      if (hover && hover.material && hover.material.emissive){
        hover.userData.__emH = hover.material.emissive.getHex();
        hover.material.emissive.setHex(0x223377);
      }
      if (hover && hover.userData.type==='portal'){
        hover.children?.[1]?.material?.color?.setHex(0xffe08a);
      }
      if (!hover && selected && selected.material && selected.material.emissive){
        selected.material.emissive.setHex(selected.userData.__em||0x000000);
      }
    }
  });

  function topOwner(obj){
    while (obj && !obj.userData?.type && obj.parent) obj = obj.parent;
    return obj;
  }

  renderer.domElement.addEventListener('mousedown', (e)=>{
    if (mode!=='edit') return;
    const hits = worldFromMouse(e, [ground, ...buildings, ...walls, ...portals]);
    if (tool==='select'){
      const hit = hits[0];
      setSelected(hit ? topOwner(hit.object) : null);
      if (selected?.userData?.type==='building'){
        rngHeight.value = selected.userData.size.h;
        colorInput.value = toHex(selected.material.color.getHex());
        nameInput.value = selected.userData.name || '';
      } else if (selected?.userData?.type==='token'){
        nameInput.value = selected.userData.label || '';
      } else if (selected?.userData?.type==='portal'){
        nameInput.value = selected.userData.tag || '';
      }
    }
    else if (tool==='build'){
      const hit = hits.find(h=> h.object===ground);
      if (!hit) return;
      const p = snapV3(hit.point);
      const h = Number(rngHeight.value);
      const col = parseInt(colorInput.value.replace('#',''),16);
      const b = addBuilding(new THREE.Vector3(p.x,0,p.z), 12, 12, h, col);
      setSelected(b);
    }
    else if (tool==='paint'){
      const hit = hits[0];
      const target = hit ? topOwner(hit.object) : null;
      if (!target) return;
      const col = parseInt(colorInput.value.replace('#',''),16);
      const h = Number(rngHeight.value);
      if (target.userData.type==='building'){
        target.material.color.setHex(col);
        // resize height
        const size = target.userData.size;
        size.h = h;
        target.scale.y = h / (target.geometry.parameters.height || size.h);
        target.position.y = h/2;
        target.updateMatrixWorld();
        // refresh collider
        THREE.Box3.prototype.setFromObject.call(target.userData.collider, target);
        rebuildColliders();
      } else if (target.userData.type==='wall'){
        target.material.color.setHex(col);
      } else if (target.userData.type==='token'){
        target.material.color.setHex(col);
        target.userData.label = nameInput.value || target.userData.label;
        // update sprite
        if (target.children[0]) target.remove(target.children[0]);
        target.add(makeLabelSprite(target.userData.label));
      } else if (target.userData.type==='portal'){
        target.userData.tag = nameInput.value || '';
      }
      setSelected(target);
    }
    else if (tool==='erase'){
      const hit = hits[0]; if (!hit) return;
      const target = topOwner(hit.object);
      if (!target) return;
      removeObject(target);
    }
    else if (tool==='token'){
      const hit = hits.find(h=>h.object===ground); if (!hit) return;
      const p = snapV3(hit.point.clone());
      const label = nameInput.value || 'Token';
      const t = addToken(p, label);
      setSelected(t);
    }
    else if (tool==='wall'){
      const hit = hits.find(h=>h.object===ground); if (!hit) return;
      const p = snapV3(hit.point.clone());
      if (!wallDraft){ wallDraft = { a:p.clone() }; showHint('Click end point'); }
      else{
        addWall(wallDraft.a, p, Number(rngHeight.value));
        wallDraft = null; showHint();
      }
    }
    else if (tool==='portal'){
      const hit = hits.find(h=>h.object===ground); if (!hit) return;
      const p = snapV3(hit.point.clone());
      if (!portalDraft){
        portalDraft = { a:p.clone(), ghost:null };
        showHint('Drag to size, release to create');
        // create a tiny ghost
        portalDraft.ghost = addPortalRect(p,p,'');
        portalDraft.ghost.children.forEach(c => c.material.opacity = 0.03);
      }
    }
  });

  renderer.domElement.addEventListener('mousemove', (e)=>{
    if (mode!=='edit') return;
    if (portalDraft){
      const hits = worldFromMouse(e, [ground]); const hit = hits[0]; if (!hit) return;
      const b = snapV3(hit.point.clone());
      const a = portalDraft.a;
      // update ghost scale/position
      const x0=Math.min(a.x,b.x), x1=Math.max(a.x,b.x);
      const z0=Math.min(a.z,b.z), z1=Math.max(a.z,b.z);
      const w=x1-x0, h=z1-z0, cx=(x0+x1)/2, cz=(z0+z1)/2;
      const p = portalDraft.ghost;
      const plane = p.children[0]; const frame=p.children[1];
      plane.scale.set(w, h, 1);
      frame.scale.set(w, h, 1);
      p.position.set(cx,0,cz);
    }
  });

  addEventListener('mouseup', ()=>{
    if (portalDraft){
      // finalize
      const p = portalDraft.ghost;
      const w = Math.max(2, p.children[0].geometry.parameters.width * p.scale.x);
      const h = Math.max(2, p.children[0].geometry.parameters.height* p.scale.y);
      const a = new THREE.Vector3(p.position.x - w/2, 0, p.position.z - h/2);
      const b = new THREE.Vector3(p.position.x + w/2, 0, p.position.z + h/2);
      p.parent && p.parent.remove(p); portals.splice(portals.indexOf(p),1);
      const tag = nameInput.value || '';
      const final = addPortalRect(a,b,tag);
      setSelected(final);
      portalDraft = null; showHint();
    }
  });

  function removeObject(obj){
    const type = obj.userData.type;
    if (type==='building'){
      scene.remove(obj); buildings.splice(buildings.indexOf(obj),1);
    } else if (type==='wall'){
      scene.remove(obj); walls.splice(walls.indexOf(obj),1);
    } else if (type==='token'){
      scene.remove(obj); tokens.splice(tokens.indexOf(obj),1);
    } else if (type==='portal'){
      scene.remove(obj); portals.splice(portals.indexOf(obj),1);
    }
    setSelected(null);
    rebuildColliders();
  }

  // --- Save / Load ---
  function serialize(){
    return {
      v:1,
      camera: { pos: camera.position.toArray() },
      buildings: buildings.map(m=>({
        p: m.position.toArray(), s: [m.userData.size.w, m.userData.size.h, m.userData.size.d],
        c: m.material.color.getHex()
      })),
      walls: walls.map(w=>({
        p: w.position.toArray(), r: w.rotation.toArray(), s: w.scale.toArray(), c: w.material.color.getHex(),
        g: [w.geometry.parameters.width, w.geometry.parameters.height, w.geometry.parameters.depth]
      })),
      tokens: tokens.map(t=>({ p: t.position.toArray(), c: t.material.color.getHex(), label: t.userData.label })),
      portals: portals.map(p=>({
        p: p.position.toArray(),
        s: p.children[0].geometry.parameters, // width/height
        sc: p.scale.toArray(),
        tag: p.userData.tag||''
      })),
      settings: { snap, showGrid }
    };
  }
  function deserialize(data){
    clearScene();
    const d = data;
    if (d.camera?.pos) camera.position.fromArray(d.camera.pos);
    (d.buildings||[]).forEach(b=>{
      addBuilding(new THREE.Vector3().fromArray(b.p), b.s[0], b.s[2], b.s[1], b.c);
    });
    (d.walls||[]).forEach(w=>{
      const geo = new THREE.BoxGeometry(w.g[0], w.g[1], w.g[2]);
      const mat = new THREE.MeshStandardMaterial({ color:w.c, roughness:.8, metalness:.02 });
      const m = new THREE.Mesh(geo, mat);
      m.position.fromArray(w.p); m.rotation.fromArray(w.r); m.scale.fromArray(w.sc||[1,1,1]);
      m.castShadow = m.receiveShadow = true; m.userData.type='wall';
      scene.add(m); walls.push(m);
    });
    (d.tokens||[]).forEach(t=>{
      addToken(new THREE.Vector3().fromArray(t.p), t.label||'Token', t.c);
    });
    (d.portals||[]).forEach(p=>{
      const a = new THREE.Vector3(p.p[0]-p.s.width/2,0,p.p[2]-p.s.height/2);
      const b = new THREE.Vector3(p.p[0]+p.s.width/2,0,p.p[2]+p.s.height/2);
      const g = addPortalRect(a,b, p.tag||'');
      g.scale.fromArray(p.sc||[1,1,1]);
      g.position.fromArray(p.p);
    });
    snap = !!(d.settings?.snap);
    showGrid = !!(d.settings?.showGrid);
    chkSnap.checked = snap;
    chkGrid.checked = showGrid;
    gridHelper.visible = showGrid;
    rebuildColliders();
  }

  btnSave.addEventListener('click', ()=>{
    const payload = serialize();
    localStorage.setItem('warvault3d-scene', JSON.stringify(payload));
    toast('Saved locally.');
  });
  btnLoad.addEventListener('click', ()=>{
    const raw = localStorage.getItem('warvault3d-scene');
    if (!raw) return toast('Nothing saved yet.');
    try { deserialize(JSON.parse(raw)); toast('Loaded.'); } catch { toast('Load failed'); }
  });
  btnExport.addEventListener('click', ()=>{
    const blob = new Blob([JSON.stringify(serialize(), null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'warvault3d-scene.json';
    a.click(); URL.revokeObjectURL(a.href);
  });
  fileImport.addEventListener('change', e=>{
    const f = e.target.files?.[0]; if (!f) return;
    const r = new FileReader();
    r.onload = ev => { try{ deserialize(JSON.parse(ev.target.result)); toast('Imported.'); } catch { toast('Import failed'); } };
    r.readAsText(f);
    fileImport.value='';
  });

  // Scene buttons
  btnGen.addEventListener('click', generateCity);
  btnClear.addEventListener('click', clearScene);

  // Mode toggles
  function setMode(newMode){
    mode = newMode;
    if (mode==='walk'){
      orbit.enabled = false;
      if (!walking) fp.lock();
      walking = true;
      btnWalk.classList.add('primary');
      btnEdit.classList.remove('primary');
      showHint('Walk mode (press E to Edit)');
    }else{
      fp.unlock();
      walking = false;
      orbit.enabled = true;
      btnEdit.classList.add('primary');
      btnWalk.classList.remove('primary');
      showHint('Edit mode (press E to Walk)');
    }
  }
  btnWalk.addEventListener('click', ()=> setMode('walk'));
  btnEdit.addEventListener('click', ()=> setMode('edit'));

  // UI toggles
  chkGrid.addEventListener('change', ()=>{ showGrid = chkGrid.checked; gridHelper.visible = showGrid; });
  chkSnap.addEventListener('change', ()=>{ snap = chkSnap.checked; });

  // Duplicate / Delete
  btnDuplicate.addEventListener('click', ()=>{
    if (!selected) return;
    const t = selected.userData.type;
    if (t==='building'){
      const s = selected.userData.size;
      const c = selected.material.color.getHex();
      const pos = selected.position.clone().add(new THREE.Vector3(2,0,2));
      const m = addBuilding(pos, s.w, s.d, s.h, c); setSelected(m);
    }else if (t==='token'){
      const pos = selected.position.clone().add(new THREE.Vector3(1,0,1));
      const t2 = addToken(pos, selected.userData.label, selected.material.color.getHex()); setSelected(t2);
    }else if (t==='wall'){
      const pos = selected.position.clone().add(new THREE.Vector3(2,0,2));
      const g = selected.geometry.parameters;
      const m = new THREE.Mesh(new THREE.BoxGeometry(g.width,g.height,g.depth),
        new THREE.MeshStandardMaterial({ color:selected.material.color.getHex(), roughness:.8 }));
      m.position.copy(pos); m.rotation.copy(selected.rotation);
      m.castShadow=m.receiveShadow=true; m.userData.type='wall';
      scene.add(m); walls.push(m); setSelected(m); rebuildColliders();
    }else if (t==='portal'){
      const p = selected.position.clone().add(new THREE.Vector3(2,0,2));
      const w = selected.children[0].geometry.parameters.width;
      const h = selected.children[0].geometry.parameters.height;
      const tag = selected.userData.tag||'';
      const m = addPortalRect(new THREE.Vector3(p.x-w/2,0,p.z-h/2), new THREE.Vector3(p.x+w/2,0,p.z+h/2), tag);
      setSelected(m);
    }
  });
  btnDelete.addEventListener('click', ()=>{ if (selected) removeObject(selected); });

  // Walk input
  addEventListener('keydown', (e)=>{
    keys[e.code]=true;
    if (e.code==='KeyE'){ setMode(mode==='walk'?'edit':'walk'); }
    if (mode==='edit'){
      if (e.code==='Delete'){ if (selected) removeObject(selected); }
      if (e.code==='KeyG'){ snap = !snap; chkSnap.checked = snap; toast('Snap '+(snap?'ON':'OFF')); }
      if (selected && selected.userData.type==='building'){
        const s = selected.userData.size;
        if (e.code==='KeyR'){ s.h = Math.min(120, s.h+2); rngHeight.value=s.h; selected.scale.y = s.h/(selected.geometry.parameters.height||s.h); selected.position.y=s.h/2; rebuildColliders(); }
        if (e.code==='KeyF'){ s.h = Math.max(4, s.h-2); rngHeight.value=s.h; selected.scale.y = s.h/(selected.geometry.parameters.height||s.h); selected.position.y=s.h/2; rebuildColliders(); }
      }
    }
  });
  addEventListener('keyup', (e)=>{ keys[e.code]=false; });

  // Walk loop
  fp.addEventListener('lock', ()=> walking = true);
  fp.addEventListener('unlock', ()=> walking = false);

  function movePlayer(dt){
    const base = (keys['ShiftLeft']||keys['ShiftRight']) ? speed*sprint : speed;
    const dir = new THREE.Vector3(
      (keys['KeyD']?1:0) - (keys['KeyA']?1:0),
      0,
      (keys['KeyS']?1:0) - (keys['KeyW']?1:0)
    ).normalize().multiplyScalar(base*dt);
    // transform relative to camera yaw
    const yaw = camera.rotation.y;
    const cs=Math.cos(yaw), sn=Math.sin(yaw);
    const vx = dir.x*cs - dir.z*sn;
    const vz = dir.x*sn + dir.z*cs;

    const pos = fpObject.position.clone();
    pos.y = playerHeight;

    const next = pos.clone().add(new THREE.Vector3(vx,0,vz));

    // Simple xz collision: keep player outside colliders expanded by radius
    const blocked = colliders.some(box=>{
      // check overlap in xz plane
      const min = box.min, max = box.max;
      const nx = Math.max(min.x - next.x, 0, next.x - max.x);
      const nz = Math.max(min.z - next.z, 0, next.z - max.z);
      const distSq = nx*nx + nz*nz;
      return distSq < playerRadius*playerRadius;
    });

    if (!blocked){
      fpObject.position.copy(next);
      fpObject.position.y = playerHeight;
      // portal trigger
      checkPortalTeleport(next);
    }
  }

  function checkPortalTeleport(playerPos){
    for (const p of portals){
      const w = p.children[0].geometry.parameters.width * p.scale.x;
      const h = p.children[0].geometry.parameters.height* p.scale.y;
      const x0 = p.position.x - w/2, x1 = p.position.x + w/2;
      const z0 = p.position.z - h/2, z1 = p.position.z + h/2;
      if (playerPos.x>=x0 && playerPos.x<=x1 && playerPos.z>=z0 && playerPos.z<=z1){
        const tag = p.userData.tag;
        if (!tag) return;
        const mates = portals.filter(q=> q!==p && q.userData.tag===tag);
        if (!mates.length) return;
        const to = mates[0];
        fpObject.position.set(to.position.x, playerHeight, to.position.z);
        toast('Teleported to "'+tag+'"');
        break;
      }
    }
  }

  // Hints / toast
  let toastTimer=0;
  function toast(msg){
    hint.textContent = msg; hint.style.display='block';
    clearTimeout(toastTimer); toastTimer = setTimeout(()=> hint.style.display='none', 1600);
  }
  function showHint(toolName){
    const map = {
      select:'Select objects. Click a building/token/portal.',
      build:'Click ground to add a building.',
      wall:'Click start → click end to add a wall.',
      paint:'Click object to apply Height/Color (or set portal tag).',
      token:'Click ground to add a labeled token.',
      portal:'Drag on ground to create a gold-framed portal. Use the Name field to tag it. Two portals with the same tag link.',
      erase:'Click any object to delete it.',
    };
    if (!toolName){ hint.style.display='none'; return; }
    toast(map[toolName] || toolName);
  }

  // Start
  generateCity();
  setMode('edit');

  // Animation loop
  const clock = new THREE.Clock();
  renderer.setAnimationLoop(()=>{
    const dt = Math.min(0.033, clock.getDelta());
    if (mode==='walk' && walking) movePlayer(dt); else orbit.update();
    renderer.render(scene, camera);
  });
})();
</script>
</body>
</html>
